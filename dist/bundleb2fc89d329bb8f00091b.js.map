{"version":3,"file":"bundleb2fc89d329bb8f00091b.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC3E2C;AACE;AACZ;AACmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACO,kBAAkB,oDAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6DAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,gCAAgC,0CAAI;AACpC;AACA;AACA,sBAAsB,sDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,sDAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAQ,yBAAyB,KAAK;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACvkBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,YAAY,iBAAiB,iBAAiB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB,gBAAgB,iBAAiB;AACjC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACzE2C;AACM;AAClB;AACqC;AAC7D,sBAAsB,oDAAS;AACtC;AACA;AACA;AACA,8BAA8B,wCAAG;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mDAAM;AACrC;AACA;AACA;AACA;AACA;AACA,0BAA0B,mDAAM;AAChC;AACA;AACA;AACA;AACA;AACA,qCAAqC,mDAAM;AAC3C;AACA;AACA;AACA;AACA;AACA,4BAA4B,mDAAM;AAClC;AACA;AACA;AACA;AACA;AACA,uCAAuC,mDAAM;AAC7C;AACA;AACA;AACA;AACA;AACA,kCAAkC,mDAAM;AACxC;AACA;AACA;AACA;AACA;AACA,6CAA6C,mDAAM;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,mDAAM;AAC/B;AACA;AACA;AACA;AACA;AACA,oCAAoC,mDAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mDAAM;AACjC;AACA;AACA;AACA,yBAAyB,mDAAM;AAC/B,gCAAgC,qEAAwB;AACxD;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA,cAAc,wCAAG;AACjB,sBAAsB,wCAAG;AACzB;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK;AACrB;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA,sBAAsB,EAAE;AACxB;AACA;AACA;AACA,sBAAsB,0DAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAY;AAClC;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/fgH;AAClE;AACa;AACpB;AACvC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,SAAS;AACxB,eAAe,iBAAiB;AAChC,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,kBAAkB,iEAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8DAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6DAAc;AACjC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA,0BAA0B,gDAAO;AACjC;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wDAAS;AACvC,oDAAoD,wDAAS;AAC7D,4BAA4B,uDAAU,WAAW,oEAAU,qBAAqB,wDAAS;AACzF,YAAY,6DAAc;AAC1B;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtEkE;AAC3D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAa;AACnC;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/E2C;AACpC;AACP,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/BU;;;;;;;;;;;;;;;;;;;;;;ACAiC;AACA;AACyC;AAChC;AACc;AACtB;AACY;AACjD;AACP,+BAA+B,6DAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAa,8BAA8B,gBAAgB,aAAa,QAAQ;AACtG;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oDAAO;AAC/B,uBAAuB,uDAAU,QAAQ,uDAAU,qBAAqB,oDAAS;AACjF;AACA,gCAAgC,gEAAe;AAC/C;AACA;AACA;AACA,0BAA0B,oDAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,oDAAM;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAa,mBAAmB,QAAQ,IAAI,IAAI,IAAI,YAAY;AAC1F;AACA,SAAS;AACT;AACA,eAAe,oDAAS;AACxB;AACA;AACA,yBAAyB,oDAAS;AAClC;AACA,wBAAwB,oDAAO;AAC/B,8BAA8B,uDAAU,oCAAoC,oDAAS,CAAC,oDAAM,YAAY,oDAAS,CAAC,oDAAM;AACxH;AACA,wBAAwB,oDAAO;AAC/B,0BAA0B,oDAAS;AACnC;AACA;AACA,gCAAgC,gEAAe;AAC/C;AACA;AACA,0BAA0B,oDAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,oDAAM;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gEAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2DAAa;AAC3C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzGmD;AACC;AAC7C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,qBAAqB;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,4DAAe;AAC3G;AACA,qFAAqF,4DAAe;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sBAAsB,2DAAa;AACnC;AACA;AACA,sBAAsB,2DAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAa,qBAAqB,gBAAgB;AACxE;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnIO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACR8C;AACS;AAChD;AACP;AACA,eAAe,sDAAU;AACzB;AACA;AACA;AACA,sBAAsB,2DAAa;AACnC;AACA;AACA,qBAAqB,sDAAU;AAC/B;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACd8C;AACO;AACN;AACc;AAChB;AACE;AACwC;AACxB;AACxD;AACP;AACA,SAAS,mDAAM,WAAW,sDAAU;AACpC,SAAS,mDAAM,WAAW,wDAAW;AACrC,SAAS,mDAAM,eAAe,wDAAW;AACzC,SAAS,mDAAM,SAAS,sDAAU;AAClC,SAAS,mDAAM,cAAc,sDAAU;AACvC,SAAS,mDAAM,iBAAiB,sDAAU;AAC1C,SAAS,mDAAM,mBAAmB,wDAAW;AAC7C,SAAS,mDAAM,qBAAqB,sDAAU;AAC9C,SAAS,mDAAM,iBAAiB,sDAAU;AAC1C,SAAS,mDAAM,qBAAqB,8DAAc;AAClD,SAAS,mDAAM,wBAAwB,8DAAc;AACrD,SAAS,mDAAM,wBAAwB,sEAAkB;AACzD,SAAS,mDAAM,mBAAmB,sEAAkB;AACpD,SAAS,mDAAM,8BAA8B,sEAAkB;AAC/D,SAAS,mDAAM,uBAAuB,8DAAc;AACpD,SAAS,mDAAM,wBAAwB,wDAAW;AAClD,SAAS,mDAAM,kBAAkB,wEAAmB;AACpD,SAAS,mDAAM,6BAA6B,wEAAmB;AAC/D,SAAS,mDAAM,yBAAyB,gGAA+B;AACvE,qBAAqB,sDAAU;AAC/B,SAAS,mDAAM,oBAAoB,wEAAmB;AACtD,SAAS,mDAAM,kBAAkB,wEAAmB;AACpD,SAAS,mDAAM,qBAAqB,sEAAkB;AACtD,SAAS,mDAAM,gCAAgC,sEAAkB;AACjE,SAAS,mDAAM,qBAAqB,sDAAU;AAC9C,SAAS,mDAAM,2BAA2B,sEAAkB;AAC5D,SAAS,mDAAM,sCAAsC,sEAAkB;AACvE;AACA;;;;;;;;;;;;;;;;;;ACtCqD;AACC;AACR;AACvC;AACP;AACA;AACA,wBAAwB,cAAc;AACtC,yBAAyB,8DAAc;AACvC;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAa;AACnC;AACA,2BAA2B,mDAAM;AACjC,wBAAwB,cAAc;AACtC,gBAAgB,8DAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxBsE;AAC/D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAa,IAAI,OAAO,2BAA2B,QAAQ;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAa;AACnC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxB8C;AACwB;AAC/D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAa,2BAA2B,MAAM;AACpE;AACA;AACA,sBAAsB,2DAAa,0BAA0B,SAAS;AACtE;AACA;AACA,mCAAmC,sDAAU;AAC7C,oCAAoC,sDAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAU;AAC1C,iCAAiC,sDAAU;AAC3C;AACA;AACA;AACA,sBAAsB,2DAAa;AACnC;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACnC4C;AACS;AACC;AACT;AACuC;AAC7E;AACP;AACA;AACA,wBAAwB,sDAAU,kCAAkC,oDAAS;AAC7E;AACA;AACA;AACA;AACA;AACA,6BAA6B,sDAAU,mCAAmC,oDAAS;AACnF,6BAA6B,sDAAU,yCAAyC,oDAAS;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,8DAAc;AACpD,sCAAsC,sDAAU,iBAAiB,oDAAS;AAC1E;AACA,0CAA0C,sDAAU,kBAAkB,oDAAS;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sDAAU,oBAAoB,oDAAS;AACpE;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,2BAA2B,qEAAwB;AACnD,gCAAgC,sDAAU,oCAAoC,oDAAS,mBAAmB,oDAAS;AACnH,iBAAiB,oDAAS;AAC1B,wBAAwB,qBAAqB;AAC7C;AACA,8BAA8B,sDAAU,oCAAoC,oDAAS,aAAa,oDAAS;AAC3G,qBAAqB,oDAAS;AAC9B;AACA,oCAAoC,sDAAU,oCAAoC,oDAAS,mBAAmB,oDAAS;AACvH,qBAAqB,oDAAS;AAC9B,2CAA2C,+DAAkB;AAC7D;AACA,+BAA+B,sDAAU,oCAAoC,oDAAS,cAAc,oDAAS;AAC7G,qBAAqB,oDAAS;AAC9B,4BAA4B,gBAAgB;AAC5C,iCAAiC,8DAAc,oCAAoC,oDAAS;AAC5F,yBAAyB,oDAAS;AAClC,4CAA4C,sDAAU,oCAAoC,oDAAS,YAAY,oDAAS;AACxH,yBAAyB,oDAAS;AAClC;AACA,wCAAwC,sDAAU,oCAAoC,oDAAS,YAAY,oDAAS;AACpH,6BAA6B,oDAAS;AACtC;AACA,kCAAkC,2DAAa,oCAAoC,aAAa,eAAe,oBAAoB;AACnI;AACA,sDAAsD,kBAAkB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5GO;AACP;AACA;AACA;AACA,CAAC,gDAAgD;;;;;;;;;;;;;;;;;;;;;;ACJH;AACN;AACK;AACQ;AACQ;AACA;AACP;AAC/C;AACP;AACA;AACA;AACA;AACA;AACA,yBAAyB,sDAAU,qBAAqB,gDAAS;AACjE;AACA;AACA;AACA;AACA,6BAA6B,gDAAS,SAAS,gDAAS;AACxD;AACA,gCAAgC,gDAAS,gBAAgB,gDAAS,iBAAiB,gDAAS;AAC5F;AACA,yCAAyC,gDAAS;AAClD;AACA;AACA;AACA,wBAAwB,8DAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gDAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gDAAS;AAC5C,mCAAmC,gDAAS;AAC5C;AACA;AACA,SAAS;AACT;AACA,iCAAiC,sEAAkB;AACnD;AACA;AACA;AACA,iCAAiC,sEAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAU,4BAA4B,gDAAS,SAAS,gDAAS;AACvF,iBAAiB,gDAAS;AAC1B,6BAA6B,sDAAU,6BAA6B,gDAAS;AAC7E,iBAAiB,gDAAS;AAC1B;AACA;AACA;AACA,6BAA6B,sEAAkB;AAC/C,yBAAyB,mDAAM;AAC/B;AACA;AACA,8BAA8B,2DAAa;AAC3C;AACA;AACA;AACA;AACA,+BAA+B,sDAAU,4BAA4B,gDAAS,cAAc,gDAAS;AACrG,qBAAqB,gDAAS;AAC9B;AACA,4BAA4B,gBAAgB;AAC5C;AACA,kCAAkC,8DAAc;AAChD,yBAAyB,gDAAS;AAClC;AACA;AACA;AACA;AACA,gCAAgC,sDAAU,4BAA4B,gDAAS,YAAY,gDAAS;AACpG,yBAAyB,gDAAS;AAClC;AACA;AACA,qCAAqC,sDAAU,4BAA4B,gDAAS,YAAY,gDAAS;AACzG,6BAA6B,gDAAS;AACtC;AACA,0CAA0C,eAAe;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sEAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAU,oBAAoB,gDAAS;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8DAAc;AACzC;AACA,2BAA2B,sDAAU,kBAAkB,gDAAS;AAChE;AACA;AACA,+BAA+B,sDAAU,kBAAkB,gDAAS;AACpE;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3JoC;AACH;AACI;AACG;AACR;AACC;AACoB;AACb;AACC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACRV;AACA;AACM;AACD;AACI;AACP;AACG;;;;;;;;;;;;;;;;ACNmB;AAChD;AACP;AACA,SAAS,oDAAO;AAChB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB;AACA;AACA;AACA,SAAS,oDAAO;AAChB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB;AACA,SAAS,oDAAO;AAChB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB,YAAY,mDAAM;AAClB;AACA,SAAS,oDAAO;AAChB,YAAY,mDAAM;AAClB;AACA,SAAS,oDAAO;AAChB,YAAY,mDAAM;AAClB;AACA;AACA;;;;;;;;;;;;;;;;ACpDwD;AACjD;AACP;AACA,QAAQ,oDAAO;AACf;AACA;AACA,QAAQ,oDAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oDAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mDAAM;AACnD,mCAAmC,oDAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mDAAM,wBAAwB,mDAAM;AACpE,uCAAuC,oDAAO;AAC9C;AACA;AACA;AACA;AACA;AACA,mCAAmC,oDAAO;AAC1C;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnDU;;;;;;;;;;;;;;;;;;;ACAV;AACmC;AACE;AACG;;;;;;;;;;;;;;;ACHxC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACyB;;;;;;;;;;;;;;;ACjBzB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACyB;;;;;;;;;;;;;;;ACjBzB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACoB;;;;;;;;;;;;;;;ACjBpB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA,+BAA+B,aAAa,aAAa,WAAW,EAAE,IAAI;AAC1E;AACA;AACA;AACwB;;;;;;;;;;;;;;;;;;;;;;AClBW;AACA;AACL;AACI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACHlC;AACmC;AACD;AACD;AACF;AACN;AACC;AACG;AACC;;;;;;;;;;;;;;;;ACRc;AACrC,+BAA+B,oDAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC1QO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzCU;;;;;;;;;;;;;;;ACAH;AACP;AACA;AACA;AACA;AACA,CAAC,8EAA8E;;;;;;;;;;;;;;;ACLxE;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5BU;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;ACAkC;AACM;AACK;AAChD,iCAAiC,oDAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,eAAe,iBAAiB;AAChC;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe,EAAE,iCAAiC,EAAE,qBAAqB;AAC3F;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gEAAe;AACrD,yCAAyC,gEAAe;AACxD,yCAAyC,gEAAe;AACxD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACpE6D;AACJ;AACF;AACX;AACrC,uCAAuC,oDAAS;AACvD;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gEAAe;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gEAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gEAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,oBAAoB;AACnC,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,uCAAuC,kEAAgB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA,mCAAmC,kEAAgB,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oBAAoB;AACnC;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,oBAAoB;AACnC,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sEAAkB;AAChD;AACA;AACA;AACA,0BAA0B,sEAAkB;AAC5C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,2BAA2B,sEAAkB;AAC7C,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,oBAAoB;AACnC,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,sEAAkB;AAC7D;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC7RA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;;;;;;;;;;;;;;;ACnBpC;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;;;;;;;;;;;;;;;ACNY;AAChC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf,QAAQ,gDAAO;AACf;AACA;AACA,SAAS,gDAAO;AAChB,SAAS,gDAAO;AAChB,SAAS,gDAAO;AAChB,SAAS,gDAAO;AAChB;AACA;;;;;;;;;;;;;;;;;ACpB4C;AACM;AAClD;AACA;AACA;AACO,qBAAqB,oDAAS;AACrC;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,gBAAgB;AAChB;AACA;AACA,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChKU;;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAV;AACU;;;;;;;;;;;;ACDA;;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;ACAV;AACwC;AACN;AACL;AACG;AACF;AACD;AACF;AACC;AACI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACTM;AACA;AACV;AACA;AACA;AACY;AACM;AACS;AACjB;AACD;AACR;AACG;AACJ;AACG;;;;;;;UCb/B;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACNwC;AAExC,IAAMC,aAAa,GAAGD,kDAAQ,CAACE,MAAM,CACnC,mdACF,CAAC;AAEDC,OAAO,CAACC,GAAG,CAACH,aAAa,CAAC,C","sources":["webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/Cloneable.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/GVL.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/Json.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/TCModel.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/TCString.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/encoder/Base64Url.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/encoder/BitLength.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/encoder/EncodingOptions.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/encoder/SegmentEncoder.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/encoder/SemanticPreEncoder.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/encoder/field/BooleanEncoder.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/encoder/field/DateEncoder.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/encoder/field/FieldEncoderMap.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/encoder/field/FixedVectorEncoder.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/encoder/field/IntEncoder.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/encoder/field/LangEncoder.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/encoder/field/PurposeRestrictionVectorEncoder.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/encoder/field/VectorEncodingType.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/encoder/field/VendorVectorEncoder.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/encoder/field/index.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/encoder/index.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/encoder/sequence/FieldSequence.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/encoder/sequence/SegmentSequence.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/encoder/sequence/SequenceVersionMap.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/encoder/sequence/index.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/errors/DecodingError.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/errors/EncodingError.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/errors/GVLError.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/errors/TCModelError.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/errors/index.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/index.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/BinarySearchTree.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/ConsentLanguages.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/DeviceDisclosure.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/DeviceDisclosureStorageAccessType.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/Fields.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/IntMap.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/KeyMap.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/PurposeRestriction.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/PurposeRestrictionVector.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/RestrictionType.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/Segment.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/SegmentIDs.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/Vector.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/gvl/ByPurposeVendorMap.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/gvl/Declarations.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/gvl/Feature.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/gvl/GVLMapItem.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/gvl/IDSetMap.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/gvl/Purpose.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/gvl/Stack.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/gvl/Vendor.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/gvl/VendorList.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/gvl/index.js","webpack://consentstringdecoder/./node_modules/@iabtcf/core/lib/mjs/model/index.js","webpack://consentstringdecoder/webpack/bootstrap","webpack://consentstringdecoder/webpack/runtime/define property getters","webpack://consentstringdecoder/webpack/runtime/hasOwnProperty shorthand","webpack://consentstringdecoder/webpack/runtime/make namespace object","webpack://consentstringdecoder/./src/index.js"],"sourcesContent":["/**\n * Abstract Class Cloneable<T> can be extended to give the child class the ability to clone its self.\n * The child class must pass its class to super. You can then pass any needed arguments to help build\n * the cloned class to the protected _clone() method.\n *\n * Example:\n *\n * class Example extends Cloneable<Example> {\n *\n * }\n * Todo: There must be more non primitive build in types to check. But for our current purposes, this works great.\n */\nexport class Cloneable {\n    /**\n     * clone - returns a copy of the classes with new values and not references\n     *\n     * @return {T}\n     */\n    clone() {\n        const myClone = new this.constructor();\n        const keys = Object.keys(this);\n        keys.forEach((key) => {\n            const value = this.deepClone(this[key]);\n            if (value !== undefined) {\n                myClone[key] = value;\n            }\n        });\n        return myClone;\n    }\n    ;\n    /**\n     * deepClone - recursive function that makes copies of reference values\n     *\n     * @param {unknown} item\n     * @return {unknown}\n     */\n    deepClone(item) {\n        const itsType = typeof item;\n        if (itsType === 'number' || itsType === 'string' || itsType === 'boolean') {\n            return item;\n        }\n        else if (item !== null && itsType === 'object') {\n            if (typeof item.clone === 'function') {\n                return item.clone();\n            }\n            else if (item instanceof Date) {\n                return new Date(item.getTime());\n            }\n            else if (item[Symbol.iterator] !== undefined) {\n                const ar = [];\n                for (const subItem of item) {\n                    ar.push(this.deepClone(subItem));\n                }\n                if (item instanceof Array) {\n                    return ar;\n                }\n                else {\n                    return new item.constructor(ar);\n                }\n            }\n            else {\n                const retr = {};\n                for (const prop in item) {\n                    if (item.hasOwnProperty(prop)) {\n                        retr[prop] = this.deepClone(item[prop]);\n                    }\n                }\n                return retr;\n            }\n        }\n        /**\n         * ignore functions because those will be initialized with the cloning\n         * process\n         */\n    }\n}\n","import { Cloneable } from './Cloneable.js';\nimport { GVLError } from './errors/index.js';\nimport { Json } from './Json.js';\nimport { ConsentLanguages } from './model/index.js';\n/**\n * class with utilities for managing the global vendor list.  Will use JSON to\n * fetch the vendor list from specified url and will serialize it into this\n * object and provide accessors.  Provides ways to group vendors on the list by\n * purpose and feature.\n */\nexport class GVL extends Cloneable {\n    static LANGUAGE_CACHE = new Map();\n    static CACHE = new Map();\n    static LATEST_CACHE_KEY = 0;\n    static DEFAULT_LANGUAGE = 'EN';\n    /**\n     * Set of available consent languages published by the IAB\n     */\n    static consentLanguages = new ConsentLanguages();\n    static baseUrl_;\n    /**\n     * baseUrl - Entities using the vendor-list.json are required by the iab to\n     * host their own copy of it to reduce the load on the iab's infrastructure\n     * so a 'base' url must be set to be put together with the versioning scheme\n     * of the filenames.\n     *\n     * @static\n     * @param {string} url - the base url to load the vendor-list.json from.  This is\n     * broken out from the filename because it follows a different scheme for\n     * latest file vs versioned files.\n     *\n     * @throws {GVLError} - If the url is http[s]://vendorlist.consensu.org/...\n     * this will throw an error.  IAB Europe requires that that CMPs and Vendors\n     * cache their own copies of the GVL to minimize load on their\n     * infrastructure.  For more information regarding caching of the\n     * vendor-list.json, please see [the TCF documentation on 'Caching the Global\n     * Vendor List'\n     * ](https://github.com/InteractiveAdvertisingBureau/GDPR-Transparency-and-Consent-Framework/blob/master/TCFv2/IAB%20Tech%20Lab%20-%20Consent%20string%20and%20vendor%20list%20formats%20v2.md#caching-the-global-vendor-list)\n     */\n    static set baseUrl(url) {\n        const notValid = /^https?:\\/\\/vendorlist\\.consensu\\.org\\//;\n        if (notValid.test(url)) {\n            throw new GVLError('Invalid baseUrl!  You may not pull directly from vendorlist.consensu.org and must provide your own cache');\n        }\n        // if a trailing slash was forgotten\n        if (url.length > 0 && url[url.length - 1] !== '/') {\n            url += '/';\n        }\n        this.baseUrl_ = url;\n    }\n    ;\n    /**\n     * baseUrl - Entities using the vendor-list.json are required by the iab to\n     * host their own copy of it to reduce the load on the iab's infrastructure\n     * so a 'base' url must be set to be put together with the versioning scheme\n     * of the filenames.\n     *\n     * @static\n     * @return {string} - returns the previously set baseUrl, the default is\n     * `undefined`\n     */\n    static get baseUrl() {\n        return this.baseUrl_;\n    }\n    /**\n     * @static\n     * @param {string} - the latest is assumed to be vendor-list.json because\n     * that is what the iab uses, but it could be different... if you want\n     */\n    static latestFilename = 'vendor-list.json';\n    /**\n     * @static\n     * @param {string} - the versioned name is assumed to be\n     * vendor-list-v[VERSION].json where [VERSION] will be replaced with the\n     * specified version.  But it could be different... if you want just make\n     * sure to include the [VERSION] macro if you have a numbering scheme, it's a\n     * simple string substitution.\n     *\n     * eg.\n     * ```javascript\n     * GVL.baseUrl = \"http://www.mydomain.com/iabcmp/\";\n     * GVL.versionedFilename = \"vendorlist?getVersion=[VERSION]\";\n     * ```\n     */\n    static versionedFilename = 'archives/vendor-list-v[VERSION].json';\n    /**\n     * @param {string} - Translations of the names and descriptions for Purposes,\n     * Special Purposes, Features, and Special Features to non-English languages\n     * are contained in a file where attributes containing English content\n     * (except vendor declaration information) are translated.  The iab publishes\n     * one following the scheme below where the LANG is the iso639-1 language\n     * code.  For a list of available translations\n     * [please go here](https://register.consensu.org/Translation).\n     *\n     * eg.\n     * ```javascript\n     * GVL.baseUrl = \"http://www.mydomain.com/iabcmp/\";\n     * GVL.languageFilename = \"purposes?getPurposes=[LANG]\";\n     * ```\n     */\n    static languageFilename = 'purposes-[LANG].json';\n    /**\n     * @param {Promise} resolved when this GVL object is populated with the data\n     * or rejected if there is an error.\n     */\n    readyPromise;\n    /**\n     * @param {number} gvlSpecificationVersion - schema version for the GVL that is used\n     */\n    gvlSpecificationVersion;\n    /**\n     * @param {number} incremented with each published file change\n     */\n    vendorListVersion;\n    /**\n     * @param {number} tcfPolicyVersion - The TCF MO will increment this value\n     * whenever a GVL change (such as adding a new Purpose or Feature or a change\n     * in Purpose wording) legally invalidates existing TC Strings and requires\n     * CMPs to re-establish transparency and consent from users. If the policy\n     * version number in the latest GVL is different from the value in your TC\n     * String, then you need to re-establish transparency and consent for that\n     * user. A version 1 format TC String is considered to have a version value\n     * of 1.\n     */\n    tcfPolicyVersion;\n    /**\n     * @param {string | Date} lastUpdated - the date in which the vendor list\n     * json file  was last updated.\n     */\n    lastUpdated;\n    /**\n     * @param {IntMap<Purpose>} a collection of [[Purpose]]s\n     */\n    purposes;\n    /**\n     * @param {IntMap<Purpose>} a collection of [[Purpose]]s\n     */\n    specialPurposes;\n    /**\n     * @param {IntMap<Feature>} a collection of [[Feature]]s\n     */\n    features;\n    /**\n     * @param {IntMap<Feature>} a collection of [[Feature]]s\n     */\n    specialFeatures;\n    /**\n     * @param {boolean} internal reference of when the GVL is ready to be used\n     */\n    isReady_ = false;\n    /**\n     * @param {IntMap<Vendor>} a collection of [[Vendor]]s\n     */\n    vendors_;\n    vendorIds;\n    /**\n     * @param {IntMap<Vendor>} a collection of [[Vendor]]. Used as a backup if a whitelist is sets\n     */\n    fullVendorList;\n    /**\n     * @param {ByPurposeVendorMap} vendors by purpose\n     */\n    byPurposeVendorMap;\n    /**\n     * @param {IDSetMap} vendors by special purpose\n     */\n    bySpecialPurposeVendorMap;\n    /**\n     * @param {IDSetMap} vendors by feature\n     */\n    byFeatureVendorMap;\n    /**\n     * @param {IDSetMap} vendors by special feature\n     */\n    bySpecialFeatureVendorMap;\n    /**\n     * @param {IntMap<Stack>} a collection of [[Stack]]s\n     */\n    stacks;\n    lang_;\n    isLatest = false;\n    /**\n     * @param {VersionOrVendorList} [versionOrVendorList] - can be either a\n     * [[VendorList]] object or a version number represented as a string or\n     * number to download.  If nothing is passed the latest version of the GVL\n     * will be loaded\n     */\n    constructor(versionOrVendorList) {\n        super();\n        /**\n         * should have been configured before and instance was created and will\n         * persist through the app\n         */\n        let url = GVL.baseUrl;\n        this.lang_ = GVL.DEFAULT_LANGUAGE;\n        if (this.isVendorList(versionOrVendorList)) {\n            this.populate(versionOrVendorList);\n            this.readyPromise = Promise.resolve();\n        }\n        else {\n            if (!url) {\n                throw new GVLError('must specify GVL.baseUrl before loading GVL json');\n            }\n            if (versionOrVendorList > 0) {\n                const version = versionOrVendorList;\n                if (GVL.CACHE.has(version)) {\n                    this.populate(GVL.CACHE.get(version));\n                    this.readyPromise = Promise.resolve();\n                }\n                else {\n                    // load version specified\n                    url += GVL.versionedFilename.replace('[VERSION]', String(version));\n                    this.readyPromise = this.fetchJson(url);\n                }\n            }\n            else {\n                /**\n                 * whatever it is (or isn't)... it doesn't matter we'll just get the\n                 * latest. In this case we may have cached the latest version at key 0.\n                 * If we have then we'll just use that instead of making a request.\n                 * Otherwise we'll have to load it (and then we'll cache it for next\n                 * time)\n                 */\n                if (GVL.CACHE.has(GVL.LATEST_CACHE_KEY)) {\n                    this.populate(GVL.CACHE.get(GVL.LATEST_CACHE_KEY));\n                    this.readyPromise = Promise.resolve();\n                }\n                else {\n                    this.isLatest = true;\n                    this.readyPromise = this.fetchJson(url + GVL.latestFilename);\n                }\n            }\n        }\n    }\n    /**\n     * emptyLanguageCache\n     *\n     * @param {string} [lang] - Optional ISO 639-1 langauge code to remove from\n     * the cache.  Should be one of the languages in GVL.consentLanguages set.\n     * If not then the whole cache will be deleted.\n     * @return {boolean} - true if anything was deleted from the cache\n     */\n    static emptyLanguageCache(lang) {\n        let retr = false;\n        if (lang === undefined && GVL.LANGUAGE_CACHE.size > 0) {\n            GVL.LANGUAGE_CACHE = new Map();\n            retr = true;\n        }\n        else if (typeof lang === 'string' && this.consentLanguages.has(lang.toUpperCase())) {\n            GVL.LANGUAGE_CACHE.delete(lang.toUpperCase());\n            retr = true;\n        }\n        return retr;\n    }\n    /**\n     * emptyCache\n     *\n     * @param {number} [vendorListVersion] - version of the vendor list to delete\n     * from the cache.  If none is specified then the whole cache is deleted.\n     * @return {boolean} - true if anything was deleted from the cache\n     */\n    static emptyCache(vendorListVersion) {\n        let retr = false;\n        if (Number.isInteger(vendorListVersion) && vendorListVersion >= 0) {\n            GVL.CACHE.delete(vendorListVersion);\n            retr = true;\n        }\n        else if (vendorListVersion === undefined) {\n            GVL.CACHE = new Map();\n            retr = true;\n        }\n        return retr;\n    }\n    cacheLanguage() {\n        if (!GVL.LANGUAGE_CACHE.has(this.lang_)) {\n            GVL.LANGUAGE_CACHE.set(this.lang_, {\n                purposes: this.purposes,\n                specialPurposes: this.specialPurposes,\n                features: this.features,\n                specialFeatures: this.specialFeatures,\n                stacks: this.stacks,\n            });\n        }\n    }\n    async fetchJson(url) {\n        try {\n            this.populate(await Json.fetch(url));\n        }\n        catch (err) {\n            throw new GVLError(err.message);\n        }\n    }\n    /**\n     * getJson - Method for getting the JSON that was downloaded to created this\n     * `GVL` object\n     *\n     * @return {VendorList} - The basic JSON structure without the extra\n     * functionality and methods of this class.\n     */\n    getJson() {\n        return JSON.parse(JSON.stringify({\n            gvlSpecificationVersion: this.gvlSpecificationVersion,\n            vendorListVersion: this.vendorListVersion,\n            tcfPolicyVersion: this.tcfPolicyVersion,\n            lastUpdated: this.lastUpdated,\n            purposes: this.purposes,\n            specialPurposes: this.specialPurposes,\n            features: this.features,\n            specialFeatures: this.specialFeatures,\n            stacks: this.stacks,\n            vendors: this.fullVendorList,\n        }));\n    }\n    /**\n     * changeLanguage - retrieves the purpose language translation and sets the\n     * internal language variable\n     *\n     * @param {string} lang - ISO 639-1 langauge code to change language to\n     * @return {Promise<void | GVLError>} - returns the `readyPromise` and\n     * resolves when this GVL is populated with the data from the language file.\n     */\n    async changeLanguage(lang) {\n        const langUpper = lang.toUpperCase();\n        if (GVL.consentLanguages.has(langUpper)) {\n            if (langUpper !== this.lang_) {\n                this.lang_ = langUpper;\n                if (GVL.LANGUAGE_CACHE.has(langUpper)) {\n                    const cached = GVL.LANGUAGE_CACHE.get(langUpper);\n                    for (const prop in cached) {\n                        if (cached.hasOwnProperty(prop)) {\n                            this[prop] = cached[prop];\n                        }\n                    }\n                }\n                else {\n                    // load Language specified\n                    const url = GVL.baseUrl + GVL.languageFilename.replace('[LANG]', lang);\n                    try {\n                        await this.fetchJson(url);\n                        this.cacheLanguage();\n                    }\n                    catch (err) {\n                        throw new GVLError('unable to load language: ' + err.message);\n                    }\n                }\n            }\n        }\n        else {\n            throw new GVLError(`unsupported language ${lang}`);\n        }\n    }\n    get language() {\n        return this.lang_;\n    }\n    isVendorList(gvlObject) {\n        return gvlObject !== undefined && gvlObject.vendors !== undefined;\n    }\n    populate(gvlObject) {\n        /**\n         * these are populated regardless of whether it's a Declarations file or\n         * a VendorList\n         */\n        this.purposes = gvlObject.purposes;\n        this.specialPurposes = gvlObject.specialPurposes;\n        this.features = gvlObject.features;\n        this.specialFeatures = gvlObject.specialFeatures;\n        this.stacks = gvlObject.stacks;\n        if (this.isVendorList(gvlObject)) {\n            this.gvlSpecificationVersion = gvlObject.gvlSpecificationVersion;\n            this.tcfPolicyVersion = gvlObject.tcfPolicyVersion;\n            this.vendorListVersion = gvlObject.vendorListVersion;\n            this.lastUpdated = gvlObject.lastUpdated;\n            if (typeof this.lastUpdated === 'string') {\n                this.lastUpdated = new Date(this.lastUpdated);\n            }\n            this.vendors_ = gvlObject.vendors;\n            this.fullVendorList = gvlObject.vendors;\n            this.mapVendors();\n            this.isReady_ = true;\n            if (this.isLatest) {\n                /**\n                 * If the \"LATEST\" was requested then this flag will be set to true.\n                 * In that case we'll cache the GVL at the special key\n                 */\n                GVL.CACHE.set(GVL.LATEST_CACHE_KEY, this.getJson());\n            }\n            /**\n             * Whether or not it's the \"LATEST\" we'll cache the gvl at the version it\n             * is declared to be (if it's not already). to avoid downloading it again\n             * in the future.\n             */\n            if (!GVL.CACHE.has(this.vendorListVersion)) {\n                GVL.CACHE.set(this.vendorListVersion, this.getJson());\n            }\n        }\n        this.cacheLanguage();\n    }\n    mapVendors(vendorIds) {\n        // create new instances of the maps\n        this.byPurposeVendorMap = {};\n        this.bySpecialPurposeVendorMap = {};\n        this.byFeatureVendorMap = {};\n        this.bySpecialFeatureVendorMap = {};\n        // initializes data structure for purpose map\n        Object.keys(this.purposes).forEach((purposeId) => {\n            this.byPurposeVendorMap[purposeId] = {\n                legInt: new Set(),\n                consent: new Set(),\n                flexible: new Set(),\n            };\n        });\n        // initializes data structure for special purpose map\n        Object.keys(this.specialPurposes).forEach((purposeId) => {\n            this.bySpecialPurposeVendorMap[purposeId] = new Set();\n        });\n        // initializes data structure for feature map\n        Object.keys(this.features).forEach((featureId) => {\n            this.byFeatureVendorMap[featureId] = new Set();\n        });\n        // initializes data structure for feature map\n        Object.keys(this.specialFeatures).forEach((featureId) => {\n            this.bySpecialFeatureVendorMap[featureId] = new Set();\n        });\n        if (!Array.isArray(vendorIds)) {\n            vendorIds = Object.keys(this.fullVendorList).map((vId) => +vId);\n        }\n        this.vendorIds = new Set(vendorIds);\n        // assigns vendor ids to their respective maps\n        this.vendors_ = vendorIds.reduce((vendors, vendorId) => {\n            const vendor = this.vendors_[String(vendorId)];\n            if (vendor && vendor.deletedDate === undefined) {\n                vendor.purposes.forEach((purposeId) => {\n                    const purpGroup = this.byPurposeVendorMap[String(purposeId)];\n                    purpGroup.consent.add(vendorId);\n                });\n                vendor.specialPurposes.forEach((purposeId) => {\n                    this.bySpecialPurposeVendorMap[String(purposeId)].add(vendorId);\n                });\n                vendor.legIntPurposes.forEach((purposeId) => {\n                    this.byPurposeVendorMap[String(purposeId)].legInt.add(vendorId);\n                });\n                // could not be there\n                if (vendor.flexiblePurposes) {\n                    vendor.flexiblePurposes.forEach((purposeId) => {\n                        this.byPurposeVendorMap[String(purposeId)].flexible.add(vendorId);\n                    });\n                }\n                vendor.features.forEach((featureId) => {\n                    this.byFeatureVendorMap[String(featureId)].add(vendorId);\n                });\n                vendor.specialFeatures.forEach((featureId) => {\n                    this.bySpecialFeatureVendorMap[String(featureId)].add(vendorId);\n                });\n                vendors[vendorId] = vendor;\n            }\n            return vendors;\n        }, {});\n    }\n    getFilteredVendors(purposeOrFeature, id, subType, special) {\n        const properPurposeOrFeature = purposeOrFeature.charAt(0).toUpperCase() + purposeOrFeature.slice(1);\n        let vendorSet;\n        const retr = {};\n        if (purposeOrFeature === 'purpose' && subType) {\n            vendorSet = this['by' + properPurposeOrFeature + 'VendorMap'][String(id)][subType];\n        }\n        else {\n            vendorSet = this['by' + (special ? 'Special' : '') + properPurposeOrFeature + 'VendorMap'][String(id)];\n        }\n        vendorSet.forEach((vendorId) => {\n            retr[String(vendorId)] = this.vendors[String(vendorId)];\n        });\n        return retr;\n    }\n    /**\n     * getVendorsWithConsentPurpose\n     *\n     * @param {number} purposeId\n     * @return {IntMap<Vendor>} - list of vendors that have declared the consent purpose id\n     */\n    getVendorsWithConsentPurpose(purposeId) {\n        return this.getFilteredVendors('purpose', purposeId, 'consent');\n    }\n    /**\n     * getVendorsWithLegIntPurpose\n     *\n     * @param {number} purposeId\n     * @return {IntMap<Vendor>} - list of vendors that have declared the legInt (Legitimate Interest) purpose id\n     */\n    getVendorsWithLegIntPurpose(purposeId) {\n        return this.getFilteredVendors('purpose', purposeId, 'legInt');\n    }\n    /**\n     * getVendorsWithFlexiblePurpose\n     *\n     * @param {number} purposeId\n     * @return {IntMap<Vendor>} - list of vendors that have declared the flexible purpose id\n     */\n    getVendorsWithFlexiblePurpose(purposeId) {\n        return this.getFilteredVendors('purpose', purposeId, 'flexible');\n    }\n    /**\n     * getVendorsWithSpecialPurpose\n     *\n     * @param {number} specialPurposeId\n     * @return {IntMap<Vendor>} - list of vendors that have declared the special purpose id\n     */\n    getVendorsWithSpecialPurpose(specialPurposeId) {\n        return this.getFilteredVendors('purpose', specialPurposeId, undefined, true);\n    }\n    /**\n     * getVendorsWithFeature\n     *\n     * @param {number} featureId\n     * @return {IntMap<Vendor>} - list of vendors that have declared the feature id\n     */\n    getVendorsWithFeature(featureId) {\n        return this.getFilteredVendors('feature', featureId);\n    }\n    /**\n     * getVendorsWithSpecialFeature\n     *\n     * @param {number} specialFeatureId\n     * @return {IntMap<Vendor>} - list of vendors that have declared the special feature id\n     */\n    getVendorsWithSpecialFeature(specialFeatureId) {\n        return this.getFilteredVendors('feature', specialFeatureId, undefined, true);\n    }\n    /**\n     * vendors\n     *\n     * @return {IntMap<Vendor>} - the list of vendors as it would on the JSON file\n     * except if `narrowVendorsTo` was called, it would be that narrowed list\n     */\n    get vendors() {\n        return this.vendors_;\n    }\n    /**\n     * narrowVendorsTo - narrows vendors represented in this GVL to the list of ids passed in\n     *\n     * @param {number[]} vendorIds - list of ids to narrow this GVL to\n     * @return {void}\n     */\n    narrowVendorsTo(vendorIds) {\n        this.mapVendors(vendorIds);\n    }\n    /**\n     * isReady - Whether or not this instance is ready to be used.  This will be\n     * immediately and synchronously true if a vendorlist object is passed into\n     * the constructor or once the JSON vendorllist is retrieved.\n     *\n     * @return {boolean} whether or not the instance is ready to be interacted\n     * with and all the data is populated\n     */\n    get isReady() {\n        return this.isReady_;\n    }\n    /**\n     * clone - overrides base `clone()` method since GVL is a special class that\n     * represents a JSON structure with some additional functionality.\n     *\n     * @return {GVL}\n     */\n    clone() {\n        const result = new GVL(this.getJson());\n        /*\n         * If the current language of the GVL is not the default language, we set the language of\n         * the clone to the current language since a new GVL is always created with the default\n         * language. */\n        if (this.lang_ !== GVL.DEFAULT_LANGUAGE) {\n            /*\n             * Since the GVL language was changed, this means that an asynchronous changeLanguage\n             * call was made prior to cloning the GVL.  The new language specified has been cached\n             * by the GVL and this changeLanguage call made as a part of cloning the GVL will be\n             * synchronous. The code will look for the language definitions in the cache instead\n             * of creating a http request. */\n            result.changeLanguage(this.lang_);\n        }\n        return result;\n    }\n    static isInstanceOf(questionableInstance) {\n        const isSo = typeof questionableInstance === 'object';\n        return (isSo && typeof questionableInstance.narrowVendorsTo === 'function');\n    }\n}\n","export class Json {\n    static absCall(url, body, sendCookies, timeout) {\n        return new Promise((resolve, reject) => {\n            const req = new XMLHttpRequest();\n            const onLoad = () => {\n                // is the response done\n                if (req.readyState == XMLHttpRequest.DONE) {\n                    /**\n                     * For our purposes if it's not a 200 range response, then it's a\n                     * failure.\n                     */\n                    if (req.status >= 200 && req.status < 300) {\n                        let response = req.response;\n                        if (typeof response === 'string') {\n                            try {\n                                response = JSON.parse(response);\n                            }\n                            catch (e) { }\n                        }\n                        resolve(response);\n                    }\n                    else {\n                        reject(new Error(`HTTP Status: ${req.status} response type: ${req.responseType}`));\n                    }\n                }\n            };\n            const onError = () => {\n                reject(new Error('error'));\n            };\n            const onAbort = () => {\n                reject(new Error('aborted'));\n            };\n            const onTimeout = () => {\n                reject(new Error('Timeout ' + timeout + 'ms ' + url));\n            };\n            req.withCredentials = sendCookies;\n            req.addEventListener('load', onLoad);\n            req.addEventListener('error', onError);\n            req.addEventListener('abort', onAbort);\n            if (body === null) {\n                req.open('GET', url, true);\n            }\n            else {\n                req.open('POST', url, true);\n            }\n            req.responseType = 'json';\n            // IE has a problem if this is before the open\n            req.timeout = timeout;\n            req.ontimeout = onTimeout;\n            req.send(body);\n        });\n    }\n    /**\n     * @static\n     * @param {string} url - full path to POST to\n     * @param {object} body - JSON object to post\n     * @param {boolean} sendCookies - Whether or not to send the XMLHttpRequest with credentials or not\n     * @param {number} [timeout] - optional timeout in milliseconds\n     * @return {Promise<object>} - if the server responds the response will be returned here\n     */\n    static post(url, body, sendCookies = false, timeout = 0) {\n        return this.absCall(url, JSON.stringify(body), sendCookies, timeout);\n    }\n    /**\n     * @static\n     * @param {string} url - full path to the json\n     * @param {boolean} sendCookies - Whether or not to send the XMLHttpRequest with credentials or not\n     * @param {number} [timeout] - optional timeout in milliseconds\n     * @return {Promise<object>} - resolves with parsed JSON\n     */\n    static fetch(url, sendCookies = false, timeout = 0) {\n        return this.absCall(url, null, sendCookies, timeout);\n    }\n}\n","import { Cloneable } from './Cloneable.js';\nimport { TCModelError } from './errors/index.js';\nimport { GVL } from './GVL.js';\nimport { PurposeRestrictionVector, Vector } from './model/index.js';\nexport class TCModel extends Cloneable {\n    /**\n     * Set of available consent languages published by the IAB\n     */\n    static consentLanguages = GVL.consentLanguages;\n    isServiceSpecific_ = false;\n    supportOOB_ = true;\n    useNonStandardStacks_ = false;\n    purposeOneTreatment_ = false;\n    publisherCountryCode_ = 'AA';\n    version_ = 2;\n    consentScreen_ = 0;\n    policyVersion_ = 2;\n    consentLanguage_ = 'EN';\n    cmpId_ = 0;\n    cmpVersion_ = 0;\n    vendorListVersion_ = 0;\n    numCustomPurposes_ = 0;\n    // Member Variable for GVL\n    gvl_;\n    created;\n    lastUpdated;\n    /**\n     * The TCF designates certain Features as special, that is, a CMP must afford\n     * the user a means to opt in to their use. These Special Features are\n     * published and numbered in the GVL separately from normal Features.\n     * Provides for up to 12 special features.\n     */\n    specialFeatureOptins = new Vector();\n    /**\n     * Renamed from `PurposesAllowed` in TCF v1.1\n     * The users consent value for each Purpose established on the legal basis\n     * of consent. Purposes are published in the Global Vendor List (see. [[GVL]]).\n     */\n    purposeConsents = new Vector();\n    /**\n     * The users permission for each Purpose established on the legal basis of\n     * legitimate interest. If the user has exercised right-to-object for a\n     * purpose.\n     */\n    purposeLegitimateInterests = new Vector();\n    /**\n     * The users consent value for each Purpose established on the legal basis\n     * of consent, for the publisher.  Purposes are published in the Global\n     * Vendor List.\n     */\n    publisherConsents = new Vector();\n    /**\n     * The users permission for each Purpose established on the legal basis of\n     * legitimate interest.  If the user has exercised right-to-object for a\n     * purpose.\n     */\n    publisherLegitimateInterests = new Vector();\n    /**\n     * The users consent value for each Purpose established on the legal basis\n     * of consent, for the publisher.  Purposes are published in the Global\n     * Vendor List.\n     */\n    publisherCustomConsents = new Vector();\n    /**\n     * The users permission for each Purpose established on the legal basis of\n     * legitimate interest.  If the user has exercised right-to-object for a\n     * purpose that is established in the publisher's custom purposes.\n     */\n    publisherCustomLegitimateInterests = new Vector();\n    /**\n     * set by a publisher if they wish to collect consent and LI Transparency for\n     * purposes outside of the TCF\n     */\n    customPurposes;\n    /**\n     * Each [[Vendor]] is keyed by id. Their consent value is true if it is in\n     * the Vector\n     */\n    vendorConsents = new Vector();\n    /**\n     * Each [[Vendor]] is keyed by id. Whether their Legitimate Interests\n     * Disclosures have been established is stored as boolean.\n     * see: [[Vector]]\n     */\n    vendorLegitimateInterests = new Vector();\n    /**\n     * The value included for disclosed vendors signals which vendors have been\n     * disclosed to the user in the interface surfaced by the CMP. This section\n     * content is required when writing a TC string to the global (consensu)\n     * scope. When a CMP has read from and is updating a TC string from the\n     * global consensu.org storage, the CMP MUST retain the existing disclosure\n     * information and only add information for vendors that it has disclosed\n     * that had not been disclosed by other CMPs in prior interactions with this\n     * device/user agent.\n     */\n    vendorsDisclosed = new Vector();\n    /**\n     * Signals which vendors the publisher permits to use OOB legal bases.\n     */\n    vendorsAllowed = new Vector();\n    publisherRestrictions = new PurposeRestrictionVector();\n    /**\n     * Constructs the TCModel. Passing a [[GVL]] is optional when constructing\n     * as this TCModel may be constructed from decoding an existing encoded\n     * TCString.\n     *\n     * @param {GVL} [gvl]\n     */\n    constructor(gvl) {\n        super();\n        if (gvl) {\n            this.gvl = gvl;\n        }\n        this.updated();\n    }\n    /**\n     * sets the [[GVL]] with side effects of also setting the `vendorListVersion`, `policyVersion`, and `consentLanguage`\n     * @param {GVL} gvl\n     */\n    set gvl(gvl) {\n        /**\n         * set the reference, but make sure it's our GVL wrapper class.\n         */\n        if (!(GVL.isInstanceOf(gvl))) {\n            gvl = new GVL(gvl);\n        }\n        this.gvl_ = gvl;\n        this.publisherRestrictions.gvl = gvl;\n    }\n    /**\n     * @return {GVL} the gvl instance set on this TCModel instance\n     */\n    get gvl() {\n        return this.gvl_;\n    }\n    /**\n     * @param {number} integer - A unique ID will be assigned to each Consent\n     * Manager Provider (CMP) from the iab.\n     *\n     * @throws {TCModelError} if the value is not an integer greater than 1 as those are not valid.\n     */\n    set cmpId(integer) {\n        integer = Number(integer);\n        if (Number.isInteger(integer) && integer > 1) {\n            this.cmpId_ = integer;\n        }\n        else {\n            throw new TCModelError('cmpId', integer);\n        }\n    }\n    get cmpId() {\n        return this.cmpId_;\n    }\n    /**\n     * Each change to an operating CMP should receive a\n     * new version number, for logging proof of consent. CmpVersion defined by\n     * each CMP.\n     *\n     * @param {number} integer\n     *\n     * @throws {TCModelError} if the value is not an integer greater than 1 as those are not valid.\n     */\n    set cmpVersion(integer) {\n        integer = Number(integer);\n        if (Number.isInteger(integer) && integer > -1) {\n            this.cmpVersion_ = integer;\n        }\n        else {\n            throw new TCModelError('cmpVersion', integer);\n        }\n    }\n    get cmpVersion() {\n        return this.cmpVersion_;\n    }\n    /**\n     * The screen number is CMP and CmpVersion\n     * specific, and is for logging proof of consent.(For example, a CMP could\n     * keep records so that a publisher can request information about the context\n     * in which consent was gathered.)\n     *\n     * @param {number} integer\n     *\n     * @throws {TCModelError} if the value is not an integer greater than 0 as those are not valid.\n     */\n    set consentScreen(integer) {\n        integer = Number(integer);\n        if (Number.isInteger(integer) && integer > -1) {\n            this.consentScreen_ = integer;\n        }\n        else {\n            throw new TCModelError('consentScreen', integer);\n        }\n    }\n    get consentScreen() {\n        return this.consentScreen_;\n    }\n    /**\n     * @param {string} lang - [two-letter ISO 639-1 language\n     * code](http://www.loc.gov/standards/iso639-2/php/code_list.php) in which\n     * the CMP UI was presented\n     *\n     * @throws {TCModelError} if the value is not a length-2 string of alpha characters\n     */\n    set consentLanguage(lang) {\n        this.consentLanguage_ = lang;\n    }\n    get consentLanguage() {\n        return this.consentLanguage_;\n    }\n    /**\n     * @param {string} countryCode - [two-letter ISO 3166-1 alpha-2 country\n     * code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) of the publisher,\n     * determined by the CMP-settings of the publisher.\n     *\n     * @throws {TCModelError} if the value is not a length-2 string of alpha characters\n     */\n    set publisherCountryCode(countryCode) {\n        if (/^([A-z]){2}$/.test(countryCode)) {\n            this.publisherCountryCode_ = countryCode.toUpperCase();\n        }\n        else {\n            throw new TCModelError('publisherCountryCode', countryCode);\n        }\n    }\n    get publisherCountryCode() {\n        return this.publisherCountryCode_;\n    }\n    /**\n     * Version of the GVL used to create this TCModel. Global\n     * Vendor List versions will be released periodically.\n     *\n     * @param {number} integer\n     *\n     * @throws {TCModelError} if the value is not an integer greater than 0 as those are not valid.\n     */\n    set vendorListVersion(integer) {\n        /**\n         * first coerce to a number via leading '+' then take the integer value by\n         * bitshifting to the right.  This works on all types in JavaScript and if\n         * it's not valid then value will be 0.\n         */\n        integer = Number(integer) >> 0;\n        if (integer < 0) {\n            throw new TCModelError('vendorListVersion', integer);\n        }\n        else {\n            this.vendorListVersion_ = integer;\n        }\n    }\n    get vendorListVersion() {\n        if (this.gvl) {\n            return this.gvl.vendorListVersion;\n        }\n        else {\n            return this.vendorListVersion_;\n        }\n    }\n    /**\n     * From the corresponding field in the GVL that was\n     * used for obtaining consent. A new policy version invalidates existing\n     * strings and requires CMPs to re-establish transparency and consent from\n     * users.\n     *\n     * If a TCF policy version number is different from the one from the latest\n     * GVL, the CMP must re-establish transparency and consent.\n     *\n     * @param {number} num - You do not need to set this.  This comes\n     * directly from the [[GVL]].\n     *\n     */\n    set policyVersion(num) {\n        this.policyVersion_ = parseInt(num, 10);\n        if (this.policyVersion_ < 0) {\n            throw new TCModelError('policyVersion', num);\n        }\n    }\n    get policyVersion() {\n        if (this.gvl) {\n            return this.gvl.tcfPolicyVersion;\n        }\n        else {\n            return this.policyVersion_;\n        }\n    }\n    set version(num) {\n        this.version_ = parseInt(num, 10);\n    }\n    get version() {\n        return this.version_;\n    }\n    /**\n     * Whether the signals encoded in this TC String were from site-specific\n     * storage `true` versus global consensu.org shared storage `false`. A\n     * string intended to be stored in global/shared scope but the CMP is unable\n     * to store due to a user agent not accepting third-party cookies would be\n     * considered site-specific `true`.\n     *\n     * @param {boolean} bool - value to set. Some changes to other fields in this\n     * model will automatically change this value like adding publisher\n     * restrictions.\n     */\n    set isServiceSpecific(bool) {\n        this.isServiceSpecific_ = bool;\n    }\n    get isServiceSpecific() {\n        return this.isServiceSpecific_;\n    }\n    /**\n     * Non-standard stacks means that a CMP is using publisher-customized stack\n     * descriptions. Stacks (in terms of purposes in a stack) are pre-set by the\n     * IAB. As are titles. Descriptions are pre-set, but publishers can customize\n     * them. If they do, they need to set this bit to indicate that they've\n     * customized descriptions.\n     *\n     * @param {boolean} bool - value to set\n     */\n    set useNonStandardStacks(bool) {\n        this.useNonStandardStacks_ = bool;\n    }\n    get useNonStandardStacks() {\n        return this.useNonStandardStacks_;\n    }\n    /**\n     * Whether or not this publisher supports OOB signaling.  On Global TC String\n     * OOB Vendors Disclosed will be included if the publish wishes to no allow\n     * these vendors they should set this to false.\n     * @param {boolean} bool - value to set\n     */\n    set supportOOB(bool) {\n        this.supportOOB_ = bool;\n    }\n    get supportOOB() {\n        return this.supportOOB_;\n    }\n    /**\n     * `false` There is no special Purpose 1 status.\n     * Purpose 1 was disclosed normally (consent) as expected by Policy.  `true`\n     * Purpose 1 not disclosed at all. CMPs use PublisherCC to indicate the\n     * publishers country of establishment to help Vendors determine whether the\n     * vendor requires Purpose 1 consent. In global scope TC strings, this field\n     * must always have a value of `false`. When a CMP encounters a global scope\n     * string with `purposeOneTreatment=true` then that string should be\n     * considered invalid and the CMP must re-establish transparency and consent.\n     *\n     * @param {boolean} bool\n     */\n    set purposeOneTreatment(bool) {\n        this.purposeOneTreatment_ = bool;\n    }\n    get purposeOneTreatment() {\n        return this.purposeOneTreatment_;\n    }\n    /**\n     * setAllVendorConsents - sets all vendors on the GVL Consent (true)\n     *\n     * @return {void}\n     */\n    setAllVendorConsents() {\n        this.vendorConsents.set(this.gvl.vendors);\n    }\n    /**\n     * unsetAllVendorConsents - unsets all vendors on the GVL Consent (false)\n     *\n     * @return {void}\n     */\n    unsetAllVendorConsents() {\n        this.vendorConsents.empty();\n    }\n    /**\n     * setAllVendorsDisclosed - sets all vendors on the GVL Vendors Disclosed (true)\n     *\n     * @return {void}\n     */\n    setAllVendorsDisclosed() {\n        this.vendorsDisclosed.set(this.gvl.vendors);\n    }\n    /**\n     * unsetAllVendorsDisclosed - unsets all vendors on the GVL Consent (false)\n     *\n     * @return {void}\n     */\n    unsetAllVendorsDisclosed() {\n        this.vendorsDisclosed.empty();\n    }\n    /**\n     * setAllVendorsAllowed - sets all vendors on the GVL Consent (true)\n     *\n     * @return {void}\n     */\n    setAllVendorsAllowed() {\n        this.vendorsAllowed.set(this.gvl.vendors);\n    }\n    /**\n     * unsetAllVendorsAllowed - unsets all vendors on the GVL Consent (false)\n     *\n     * @return {void}\n     */\n    unsetAllVendorsAllowed() {\n        this.vendorsAllowed.empty();\n    }\n    /**\n     * setAllVendorLegitimateInterests - sets all vendors on the GVL LegitimateInterests (true)\n     *\n     * @return {void}\n     */\n    setAllVendorLegitimateInterests() {\n        this.vendorLegitimateInterests.set(this.gvl.vendors);\n    }\n    /**\n     * unsetAllVendorLegitimateInterests - unsets all vendors on the GVL LegitimateInterests (false)\n     *\n     * @return {void}\n     */\n    unsetAllVendorLegitimateInterests() {\n        this.vendorLegitimateInterests.empty();\n    }\n    /**\n     * setAllPurposeConsents - sets all purposes on the GVL Consent (true)\n     *\n     * @return {void}\n     */\n    setAllPurposeConsents() {\n        this.purposeConsents.set(this.gvl.purposes);\n    }\n    /**\n     * unsetAllPurposeConsents - unsets all purposes on the GVL Consent (false)\n     *\n     * @return {void}\n     */\n    unsetAllPurposeConsents() {\n        this.purposeConsents.empty();\n    }\n    /**\n     * setAllPurposeLegitimateInterests - sets all purposes on the GVL LI Transparency (true)\n     *\n     * @return {void}\n     */\n    setAllPurposeLegitimateInterests() {\n        this.purposeLegitimateInterests.set(this.gvl.purposes);\n    }\n    /**\n     * unsetAllPurposeLegitimateInterests - unsets all purposes on the GVL LI Transparency (false)\n     *\n     * @return {void}\n     */\n    unsetAllPurposeLegitimateInterests() {\n        this.purposeLegitimateInterests.empty();\n    }\n    /**\n     * setAllSpecialFeatureOptins - sets all special featuresOptins on the GVL (true)\n     *\n     * @return {void}\n     */\n    setAllSpecialFeatureOptins() {\n        this.specialFeatureOptins.set(this.gvl.specialFeatures);\n    }\n    /**\n     * unsetAllSpecialFeatureOptins - unsets all special featuresOptins on the GVL (true)\n     *\n     * @return {void}\n     */\n    unsetAllSpecialFeatureOptins() {\n        this.specialFeatureOptins.empty();\n    }\n    setAll() {\n        this.setAllVendorConsents();\n        this.setAllPurposeLegitimateInterests();\n        this.setAllSpecialFeatureOptins();\n        this.setAllPurposeConsents();\n        this.setAllVendorLegitimateInterests();\n    }\n    unsetAll() {\n        this.unsetAllVendorConsents();\n        this.unsetAllPurposeLegitimateInterests();\n        this.unsetAllSpecialFeatureOptins();\n        this.unsetAllPurposeConsents();\n        this.unsetAllVendorLegitimateInterests();\n    }\n    get numCustomPurposes() {\n        let len = this.numCustomPurposes_;\n        if (typeof this.customPurposes === 'object') {\n            /**\n             * Keys are not guaranteed to be in order and likewise there is no\n             * requirement that the customPurposes be non-sparse.  So we have to sort\n             * and take the highest value.  Even if the set only contains 3 purposes\n             * but goes to ID 6 we need to set the number to 6 for the encoding to\n             * work properly since it's positional.\n             */\n            const purposeIds = Object.keys(this.customPurposes)\n                .sort((a, b) => Number(a) - Number(b));\n            len = parseInt(purposeIds.pop(), 10);\n        }\n        return len;\n    }\n    set numCustomPurposes(num) {\n        this.numCustomPurposes_ = parseInt(num, 10);\n        if (this.numCustomPurposes_ < 0) {\n            throw new TCModelError('numCustomPurposes', num);\n        }\n    }\n    /**\n     * updated - updates the created and lastUpdated dates with a 'now' day-level UTC timestamp\n     *\n     * @return {void}\n     */\n    updated() {\n        const date = new Date();\n        const utcDate = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));\n        this.created = utcDate;\n        this.lastUpdated = utcDate;\n    }\n}\n","import { Base64Url, BitLength, SegmentEncoder, SegmentSequence, SemanticPreEncoder, } from './encoder/index.js';\nimport { SegmentIDs } from './model/index.js';\nimport { IntEncoder } from './encoder/field/IntEncoder.js';\nimport { TCModel } from './TCModel.js';\n/**\n * Main class for encoding and decoding a\n * TCF Transparency and Consent String\n */\nexport class TCString {\n    /**\n     * encodes a model into a TCString\n     *\n     * @param {TCModel} tcModel - model to convert into encoded string\n     * @param {EncodingOptions} options - for encoding options other than default\n     * @return {string} - base64url encoded Transparency and Consent String\n     */\n    static encode(tcModel, options) {\n        let out = '';\n        let sequence;\n        tcModel = SemanticPreEncoder.process(tcModel, options);\n        /**\n           * If they pass in a special segment sequence.\n           */\n        if (Array.isArray(options?.segments)) {\n            sequence = options.segments;\n        }\n        else {\n            sequence = new SegmentSequence(tcModel, options)['' + tcModel.version];\n        }\n        sequence.forEach((segment, idx) => {\n            let dotMaybe = '';\n            if (idx < sequence.length - 1) {\n                dotMaybe = '.';\n            }\n            out += SegmentEncoder.encode(tcModel, segment) + dotMaybe;\n        });\n        return out;\n    }\n    /**\n     * Decodes a string into a TCModel\n     *\n     * @param {string} encodedTCString - base64url encoded Transparency and\n     * Consent String to decode - can also be a single or group of segments of\n     * the string\n     * @param {string} [tcModel] - model to enhance with the information.  If\n     * none is passed a new instance of TCModel will be created.\n     * @return {TCModel} - Returns populated TCModel\n     */\n    static decode(encodedTCString, tcModel) {\n        const segments = encodedTCString.split('.');\n        const len = segments.length;\n        if (!tcModel) {\n            tcModel = new TCModel();\n        }\n        for (let i = 0; i < len; i++) {\n            const segString = segments[i];\n            /**\n             * first char will contain 6 bits, we only need the first 3. In version 1\n             * and 2 of the TC string there is no segment type for the CORE string.\n             * Instead the first 6 bits are reserved for the encoding version, but\n             * because we're only on a maximum of encoding version 2 the first 3 bits\n             * in the core segment will evaluate to 0.\n             */\n            const firstChar = Base64Url.decode(segString.charAt(0));\n            const segTypeBits = firstChar.substr(0, BitLength.segmentType);\n            const segment = SegmentIDs.ID_TO_KEY[IntEncoder.decode(segTypeBits, BitLength.segmentType).toString()];\n            SegmentEncoder.decode(segString, tcModel, segment);\n        }\n        return tcModel;\n    }\n}\n","import { DecodingError, EncodingError } from '../errors/index.js';\nexport class Base64Url {\n    /**\n     * Base 64 URL character set.  Different from standard Base64 char set\n     * in that '+' and '/' are replaced with '-' and '_'.\n     */\n    static DICT = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\n    static REVERSE_DICT = new Map([\n        ['A', 0], ['B', 1], ['C', 2], ['D', 3], ['E', 4], ['F', 5],\n        ['G', 6], ['H', 7], ['I', 8], ['J', 9], ['K', 10], ['L', 11],\n        ['M', 12], ['N', 13], ['O', 14], ['P', 15], ['Q', 16], ['R', 17],\n        ['S', 18], ['T', 19], ['U', 20], ['V', 21], ['W', 22], ['X', 23],\n        ['Y', 24], ['Z', 25], ['a', 26], ['b', 27], ['c', 28], ['d', 29],\n        ['e', 30], ['f', 31], ['g', 32], ['h', 33], ['i', 34], ['j', 35],\n        ['k', 36], ['l', 37], ['m', 38], ['n', 39], ['o', 40], ['p', 41],\n        ['q', 42], ['r', 43], ['s', 44], ['t', 45], ['u', 46], ['v', 47],\n        ['w', 48], ['x', 49], ['y', 50], ['z', 51], ['0', 52], ['1', 53],\n        ['2', 54], ['3', 55], ['4', 56], ['5', 57], ['6', 58], ['7', 59],\n        ['8', 60], ['9', 61], ['-', 62], ['_', 63],\n    ]);\n    /**\n     * log2(64) = 6\n     */\n    static BASIS = 6;\n    static LCM = 24;\n    /**\n     * encodes an arbitrary-length bitfield string into base64url\n     *\n     * @static\n     * @param {string} str - arbitrary-length bitfield string to be encoded to base64url\n     * @return {string} - base64url encoded result\n     */\n    static encode(str) {\n        /**\n         * should only be 0 or 1\n         */\n        if (!/^[0-1]+$/.test(str)) {\n            throw new EncodingError('Invalid bitField');\n        }\n        /**\n         * Pad the end of the string to the least common mutliple of 6 (basis for\n         * base64) and 8 (one byte)\n         */\n        const padding = str.length % this.LCM;\n        str += padding ? '0'.repeat(this.LCM - padding) : '';\n        let result = '';\n        for (let i = 0; i < str.length; i += this.BASIS) {\n            result += this.DICT[parseInt(str.substr(i, this.BASIS), 2)];\n        }\n        return result;\n    }\n    /**\n     * decodes a base64url encoded bitfield string\n     *\n     * @static\n     * @param {string} str - base64url encoded bitfield string to be decoded\n     * @return {string} - bitfield string\n     */\n    static decode(str) {\n        /**\n         * should contain only characters from the base64url set\n         */\n        if (!/^[A-Za-z0-9\\-_]+$/.test(str)) {\n            throw new DecodingError('Invalidly encoded Base64URL string');\n        }\n        let result = '';\n        for (let i = 0; i < str.length; i++) {\n            /**\n             * index the binary value of the character from out reverse map\n             */\n            const strBits = this.REVERSE_DICT.get(str[i]).toString(2);\n            /**\n             * Since a bit string converted to an integer on encoding will lose\n             * leading zeros  pad to the left for those missing leading zeros\n             */\n            result += '0'.repeat(this.BASIS - strBits.length) + strBits;\n        }\n        return result;\n    }\n}\n","import { Fields } from '../model/index.js';\nexport class BitLength {\n    static [Fields.cmpId] = 12;\n    static [Fields.cmpVersion] = 12;\n    static [Fields.consentLanguage] = 12;\n    static [Fields.consentScreen] = 6;\n    static [Fields.created] = 36;\n    static [Fields.isServiceSpecific] = 1;\n    static [Fields.lastUpdated] = 36;\n    static [Fields.policyVersion] = 6;\n    static [Fields.publisherCountryCode] = 12;\n    static [Fields.publisherLegitimateInterests] = 24;\n    static [Fields.publisherConsents] = 24;\n    static [Fields.purposeConsents] = 24;\n    static [Fields.purposeLegitimateInterests] = 24;\n    static [Fields.purposeOneTreatment] = 1;\n    static [Fields.specialFeatureOptins] = 12;\n    static [Fields.useNonStandardStacks] = 1;\n    static [Fields.vendorListVersion] = 12;\n    static [Fields.version] = 6;\n    static anyBoolean = 1;\n    static encodingType = 1;\n    static maxId = 16;\n    static numCustomPurposes = 6;\n    static numEntries = 12;\n    static numRestrictions = 12;\n    static purposeId = 6;\n    static restrictionType = 2;\n    static segmentType = 3;\n    static singleOrRange = 1;\n    static vendorId = 16;\n}\n","export {};\n","import { Base64Url } from './Base64Url.js';\nimport { BitLength } from './BitLength.js';\nimport { FieldEncoderMap, IntEncoder, VendorVectorEncoder } from './field/index.js';\nimport { FieldSequence } from './sequence/index.js';\nimport { EncodingError, DecodingError } from '../errors/index.js';\nimport { Fields } from '../model/Fields.js';\nimport { Segment, SegmentIDs } from '../model/index.js';\nexport class SegmentEncoder {\n    static fieldSequence = new FieldSequence();\n    static encode(tcModel, segment) {\n        let sequence;\n        try {\n            sequence = this.fieldSequence[String(tcModel.version)][segment];\n        }\n        catch (err) {\n            throw new EncodingError(`Unable to encode version: ${tcModel.version}, segment: ${segment}`);\n        }\n        let bitField = '';\n        /**\n         * If this is anything other than the core segment we have a \"segment id\"\n         * to append to the front of the string\n         */\n        if (segment !== Segment.CORE) {\n            bitField = IntEncoder.encode(SegmentIDs.KEY_TO_ID[segment], BitLength.segmentType);\n        }\n        const fieldEncoderMap = FieldEncoderMap();\n        sequence.forEach((key) => {\n            const value = tcModel[key];\n            const encoder = fieldEncoderMap[key];\n            let numBits = BitLength[key];\n            if (numBits === undefined) {\n                if (this.isPublisherCustom(key)) {\n                    /**\n                     * publisherCustom[Consents | LegitimateInterests] are an edge case\n                     * because they are of variable length. The length is defined in a\n                     * separate field named numCustomPurposes.\n                     */\n                    numBits = Number(tcModel[Fields.numCustomPurposes]);\n                }\n            }\n            try {\n                bitField += encoder.encode(value, numBits);\n            }\n            catch (err) {\n                throw new EncodingError(`Error encoding ${segment}->${key}: ${err.message}`);\n            }\n        });\n        // base64url encode the string and return\n        return Base64Url.encode(bitField);\n    }\n    static decode(encodedString, tcModel, segment) {\n        const bitField = Base64Url.decode(encodedString);\n        let bStringIdx = 0;\n        if (segment === Segment.CORE) {\n            tcModel.version = IntEncoder.decode(bitField.substr(bStringIdx, BitLength[Fields.version]), BitLength[Fields.version]);\n        }\n        if (segment !== Segment.CORE) {\n            bStringIdx += BitLength.segmentType;\n        }\n        const sequence = this.fieldSequence[String(tcModel.version)][segment];\n        const fieldEncoderMap = FieldEncoderMap();\n        sequence.forEach((key) => {\n            const encoder = fieldEncoderMap[key];\n            let numBits = BitLength[key];\n            if (numBits === undefined) {\n                if (this.isPublisherCustom(key)) {\n                    /**\n                     * publisherCustom[Consents | LegitimateInterests] are an edge case\n                     * because they are of variable length. The length is defined in a\n                     * separate field named numCustomPurposes.\n                     */\n                    numBits = Number(tcModel[Fields.numCustomPurposes]);\n                }\n            }\n            if (numBits !== 0) {\n                /**\n                 * numBits could be 0 if this is a publisher custom purposes field and\n                 * no custom purposes are defined. If that is the case, we don't need\n                 * to gather no bits and we don't need to increment our bStringIdx\n                 * pointer because those would all be 0 increments and would mess up\n                 * the next logical if statement.\n                 */\n                const bits = bitField.substr(bStringIdx, numBits);\n                if (encoder === VendorVectorEncoder) {\n                    tcModel[key] = encoder.decode(bits, tcModel.version);\n                }\n                else {\n                    tcModel[key] = encoder.decode(bits, numBits);\n                }\n                if (Number.isInteger(numBits)) {\n                    bStringIdx += numBits;\n                }\n                else if (Number.isInteger(tcModel[key].bitLength)) {\n                    bStringIdx += tcModel[key].bitLength;\n                }\n                else {\n                    throw new DecodingError(key);\n                }\n            }\n        });\n        return tcModel;\n    }\n    static isPublisherCustom(key) {\n        return key.indexOf('publisherCustom') === 0;\n    }\n}\n","import { EncodingError } from '../errors/index.js';\nimport { RestrictionType } from '../model/index.js';\nexport class SemanticPreEncoder {\n    static processor = [\n        (tcModel) => tcModel,\n        (tcModel, gvl) => {\n            /**\n             * in case this wasn't set previously.  This should filter out invalid\n             * purpose restrictions.\n             */\n            tcModel.publisherRestrictions.gvl = gvl;\n            /**\n             * Purpose 1 is never allowed to be true for legitimate interest\n             */\n            tcModel.purposeLegitimateInterests.unset(1);\n            /**\n             * If a Vendor does not declare a purpose for consent or legitimate\n             * interest they should not have a positive signal for it. This code\n             * removes positive signals created mistakingly.\n             */\n            const vectorToIntMap = new Map();\n            vectorToIntMap.set('legIntPurposes', tcModel.vendorLegitimateInterests);\n            vectorToIntMap.set('purposes', tcModel.vendorConsents);\n            vectorToIntMap.forEach((vector, gvlVendorKey) => {\n                vector.forEach((value, vendorId) => {\n                    if (value) {\n                        const vendor = gvl.vendors[vendorId];\n                        if (!vendor || vendor.deletedDate) {\n                            /**\n                             * If the vendor doesn't exist, then they should not receive a\n                             * positive signal\n                             */\n                            vector.unset(vendorId);\n                        }\n                        else if (vendor[gvlVendorKey].length === 0) {\n                            if (gvlVendorKey === 'legIntPurposes' && vendor['purposes'].length === 0 && vendor['legIntPurposes'].length === 0 && vendor['specialPurposes'].length > 0) {\n                                /**\n                                 * Per June 2021 Policy change, Vendors declaring only Special Purposes must\n                                 * have their legitimate interest Vendor bit set if they have been disclosed.\n                                 * This empty block ensures their LI bit remains set\n                                 */\n                            }\n                            else {\n                                /**\n                                 * If the vendor does exist, but they haven't declared any\n                                 * purposes for this legal basis, then we need to see if they can\n                                 * possibly have the legal basis from their flexible purposes.\n                                 */\n                                if (tcModel.isServiceSpecific) {\n                                    if (vendor.flexiblePurposes.length === 0) {\n                                        /**\n                                         * No flexible basis for any purposes, so we can safely remove\n                                         * this vendor from the legal basis.\n                                         */\n                                        vector.unset(vendorId);\n                                    }\n                                    else {\n                                        /**\n                                         * They have some flexible purposes, we should check for a\n                                         * publisher restriction value that would enable this vendor to\n                                         * have the override-preferred basis.\n                                         */\n                                        const restrictions = tcModel.publisherRestrictions.getRestrictions(vendorId);\n                                        let isValid = false;\n                                        for (let i = 0, len = restrictions.length; i < len && !isValid; i++) {\n                                            /**\n                                             * If this condition is true the loop will break.  If we are\n                                             * dealing with the consent purposes ('purposes') and the\n                                             * publisher restriction overrides to consent then it is\n                                             * valid for the vendor to have a positive signal for\n                                             * consent.  Likewise for legitimate interest purposes\n                                             * ('legIntPurposes') and requiring legitimate interest.\n                                             */\n                                            isValid = ((restrictions[i].restrictionType === RestrictionType.REQUIRE_CONSENT &&\n                                                gvlVendorKey === 'purposes') ||\n                                                (restrictions[i].restrictionType === RestrictionType.REQUIRE_LI &&\n                                                    gvlVendorKey === 'legIntPurposes'));\n                                        }\n                                        if (!isValid) {\n                                            /**\n                                             * if we came through the previous  loop without finding a\n                                             * valid reasing: no overriding restrictions (changes in\n                                             * legal basis) then it's not valid for this vendor to have\n                                             * this legal basis.\n                                             */\n                                            vector.unset(vendorId);\n                                        }\n                                    }\n                                }\n                                else {\n                                    /**\n                                     * This is a globally-scoped string so flexible purposes will not\n                                     * be able to change this value because purposeRestrictions only\n                                     * apply to service-specific strings.\n                                     */\n                                    vector.unset(vendorId);\n                                }\n                            }\n                        }\n                    }\n                });\n            });\n            tcModel.vendorsDisclosed.set(gvl.vendors);\n            return tcModel;\n        },\n    ];\n    static process(tcModel, options) {\n        const gvl = tcModel.gvl;\n        if (!gvl) {\n            throw new EncodingError('Unable to encode TCModel without a GVL');\n        }\n        if (!gvl.isReady) {\n            throw new EncodingError('Unable to encode TCModel tcModel.gvl.readyPromise is not resolved');\n        }\n        tcModel = tcModel.clone();\n        tcModel.consentLanguage = gvl.language.toUpperCase();\n        if (options?.version > 0 && options?.version <= this.processor.length) {\n            tcModel.version = options.version;\n        }\n        else {\n            /**\n             * this is equal to the latest or most current version\n             */\n            tcModel.version = this.processor.length;\n        }\n        const processorFunctionIndex = tcModel.version - 1;\n        if (!this.processor[processorFunctionIndex]) {\n            throw new EncodingError(`Invalid version: ${tcModel.version}`);\n        }\n        return this.processor[processorFunctionIndex](tcModel, gvl);\n    }\n}\n","export class BooleanEncoder {\n    static encode(value) {\n        return String(Number(value));\n    }\n    static decode(value) {\n        // less operations than !!parseInt(value, 2)\n        return value === '1';\n    }\n}\n","import { IntEncoder, } from './IntEncoder.js';\nimport { DecodingError, } from '../../errors/index.js';\nexport class DateEncoder {\n    static encode(value, numBits) {\n        return IntEncoder.encode(Math.round(value.getTime() / 100), numBits);\n    }\n    static decode(value, numBits) {\n        if (numBits !== value.length) {\n            throw new DecodingError('invalid bit length');\n        }\n        const date = new Date();\n        date.setTime(IntEncoder.decode(value, numBits) * 100);\n        return date;\n    }\n}\n","import { Fields } from '../../model/index.js';\nimport { BooleanEncoder } from './BooleanEncoder.js';\nimport { DateEncoder } from './DateEncoder.js';\nimport { FixedVectorEncoder } from './FixedVectorEncoder.js';\nimport { IntEncoder } from './IntEncoder.js';\nimport { LangEncoder } from './LangEncoder.js';\nimport { PurposeRestrictionVectorEncoder } from './PurposeRestrictionVectorEncoder.js';\nimport { VendorVectorEncoder } from './VendorVectorEncoder.js';\nexport function FieldEncoderMap() {\n    return {\n        [Fields.version]: IntEncoder,\n        [Fields.created]: DateEncoder,\n        [Fields.lastUpdated]: DateEncoder,\n        [Fields.cmpId]: IntEncoder,\n        [Fields.cmpVersion]: IntEncoder,\n        [Fields.consentScreen]: IntEncoder,\n        [Fields.consentLanguage]: LangEncoder,\n        [Fields.vendorListVersion]: IntEncoder,\n        [Fields.policyVersion]: IntEncoder,\n        [Fields.isServiceSpecific]: BooleanEncoder,\n        [Fields.useNonStandardStacks]: BooleanEncoder,\n        [Fields.specialFeatureOptins]: FixedVectorEncoder,\n        [Fields.purposeConsents]: FixedVectorEncoder,\n        [Fields.purposeLegitimateInterests]: FixedVectorEncoder,\n        [Fields.purposeOneTreatment]: BooleanEncoder,\n        [Fields.publisherCountryCode]: LangEncoder,\n        [Fields.vendorConsents]: VendorVectorEncoder,\n        [Fields.vendorLegitimateInterests]: VendorVectorEncoder,\n        [Fields.publisherRestrictions]: PurposeRestrictionVectorEncoder,\n        segmentType: IntEncoder,\n        [Fields.vendorsDisclosed]: VendorVectorEncoder,\n        [Fields.vendorsAllowed]: VendorVectorEncoder,\n        [Fields.publisherConsents]: FixedVectorEncoder,\n        [Fields.publisherLegitimateInterests]: FixedVectorEncoder,\n        [Fields.numCustomPurposes]: IntEncoder,\n        [Fields.publisherCustomConsents]: FixedVectorEncoder,\n        [Fields.publisherCustomLegitimateInterests]: FixedVectorEncoder,\n    };\n}\n","import { BooleanEncoder } from './BooleanEncoder.js';\nimport { DecodingError } from '../../errors/index.js';\nimport { Vector } from '../../model/index.js';\nexport class FixedVectorEncoder {\n    static encode(value, numBits) {\n        let bitString = '';\n        for (let i = 1; i <= numBits; i++) {\n            bitString += BooleanEncoder.encode(value.has(i));\n        }\n        return bitString;\n    }\n    static decode(value, numBits) {\n        if (value.length !== numBits) {\n            throw new DecodingError('bitfield encoding length mismatch');\n        }\n        const vector = new Vector();\n        for (let i = 1; i <= numBits; i++) {\n            if (BooleanEncoder.decode(value[i - 1])) {\n                vector.set(i);\n            }\n        }\n        vector.bitLength = value.length;\n        return vector;\n    }\n}\n","import { EncodingError, DecodingError, } from '../../errors/index.js';\nexport class IntEncoder {\n    static encode(value, numBits) {\n        let bitString;\n        if (typeof value === 'string') {\n            value = parseInt(value, 10);\n        }\n        bitString = value.toString(2);\n        if (bitString.length > numBits || value < 0) {\n            throw new EncodingError(`${value} too large to encode into ${numBits}`);\n        }\n        // Pad the string if not filling all bits\n        if (bitString.length < numBits) {\n            // pad left\n            bitString = '0'.repeat(numBits - bitString.length) + bitString;\n        }\n        return bitString;\n    }\n    static decode(value, numBits) {\n        if (numBits !== value.length) {\n            throw new DecodingError('invalid bit length');\n        }\n        return parseInt(value, 2);\n    }\n}\n","import { IntEncoder, } from './IntEncoder.js';\nimport { DecodingError, EncodingError, } from '../../errors/index.js';\nexport class LangEncoder {\n    static encode(value, numBits) {\n        value = value.toUpperCase();\n        const ASCII_START = 65;\n        const firstLetter = value.charCodeAt(0) - ASCII_START;\n        const secondLetter = value.charCodeAt(1) - ASCII_START;\n        // check some things to throw some good errors\n        if (firstLetter < 0 || firstLetter > 25 || secondLetter < 0 || secondLetter > 25) {\n            throw new EncodingError(`invalid language code: ${value}`);\n        }\n        if (numBits % 2 === 1) {\n            throw new EncodingError(`numBits must be even, ${numBits} is not valid`);\n        }\n        numBits = numBits / 2;\n        const firstLetterBString = IntEncoder.encode(firstLetter, numBits);\n        const secondLetterBString = IntEncoder.encode(secondLetter, numBits);\n        return firstLetterBString + secondLetterBString;\n    }\n    static decode(value, numBits) {\n        let retr;\n        // is it an even number of bits? we have to divide it\n        if (numBits === value.length && !(value.length % 2)) {\n            const ASCII_START = 65;\n            const mid = value.length / 2;\n            const firstLetter = IntEncoder.decode(value.slice(0, mid), mid) + ASCII_START;\n            const secondLetter = IntEncoder.decode(value.slice(mid), mid) + ASCII_START;\n            retr = String.fromCharCode(firstLetter) + String.fromCharCode(secondLetter);\n        }\n        else {\n            throw new DecodingError('invalid bit length for language');\n        }\n        return retr;\n    }\n}\n","import { BitLength } from '../BitLength.js';\nimport { BooleanEncoder } from './BooleanEncoder.js';\nimport { DecodingError } from '../../errors/index.js';\nimport { IntEncoder } from './IntEncoder.js';\nimport { PurposeRestrictionVector, PurposeRestriction } from '../../model/index.js';\nexport class PurposeRestrictionVectorEncoder {\n    static encode(prVector) {\n        // start with the number of restrictions\n        let bitString = IntEncoder.encode(prVector.numRestrictions, BitLength.numRestrictions);\n        // if the vector is empty we'll just return a string with just the numRestricitons being 0\n        if (!prVector.isEmpty()) {\n            // create each restriction group\n            prVector.getRestrictions().forEach((purpRestriction) => {\n                // every restriction group has the purposeId and the restrictionType;\n                bitString += IntEncoder.encode(purpRestriction.purposeId, BitLength.purposeId);\n                bitString += IntEncoder.encode(purpRestriction.restrictionType, BitLength.restrictionType);\n                // now get all the vendors under that restriction\n                const vendors = prVector.getVendors(purpRestriction);\n                const len = vendors.length;\n                /**\n                 * numEntries comes first so we will have to keep a counter and the do\n                 * the encoding at the end\n                 */\n                let numEntries = 0;\n                let startId = 0;\n                let rangeField = '';\n                for (let i = 0; i < len; i++) {\n                    const vendorId = vendors[i];\n                    if (startId === 0) {\n                        numEntries++;\n                        startId = vendorId;\n                    }\n                    // we know that `len` is greater than zero because we entered the loop\n                    const lastVendorId = vendors[len - 1];\n                    const gvlVendorIds = prVector.gvl.vendorIds;\n                    const nextGvlVendor = (vendorId) => {\n                        while (++vendorId <= lastVendorId && !gvlVendorIds.has(vendorId)) {\n                        }\n                        return vendorId;\n                    };\n                    /**\n                     * either end of the loop or there are GVL vendor IDs before the next one\n                     */\n                    if (i === len - 1 || vendors[i + 1] > nextGvlVendor(vendorId)) {\n                        /**\n                         * it's a range entry if we've got something other than the start\n                         * ID\n                         */\n                        const isRange = !(vendorId === startId);\n                        // 0 means single 1 means range\n                        rangeField += BooleanEncoder.encode(isRange);\n                        rangeField += IntEncoder.encode(startId, BitLength.vendorId);\n                        if (isRange) {\n                            rangeField += IntEncoder.encode(vendorId, BitLength.vendorId);\n                        }\n                        // reset the startId so we grab the next id in the list\n                        startId = 0;\n                    }\n                }\n                /**\n                 * now that  the range encoding is built, encode the number of ranges\n                 * and then append the range field to the bitString.\n                 */\n                bitString += IntEncoder.encode(numEntries, BitLength.numEntries);\n                bitString += rangeField;\n            });\n        }\n        return bitString;\n    }\n    static decode(encodedString) {\n        let index = 0;\n        const vector = new PurposeRestrictionVector();\n        const numRestrictions = IntEncoder.decode(encodedString.substr(index, BitLength.numRestrictions), BitLength.numRestrictions);\n        index += BitLength.numRestrictions;\n        for (let i = 0; i < numRestrictions; i++) {\n            // First is purpose ID\n            const purposeId = IntEncoder.decode(encodedString.substr(index, BitLength.purposeId), BitLength.purposeId);\n            index += BitLength.purposeId;\n            // Second Restriction Type\n            const restrictionType = IntEncoder.decode(encodedString.substr(index, BitLength.restrictionType), BitLength.restrictionType);\n            index += BitLength.restrictionType;\n            const purposeRestriction = new PurposeRestriction(purposeId, restrictionType);\n            // Num Entries (number of vendors)\n            const numEntries = IntEncoder.decode(encodedString.substr(index, BitLength.numEntries), BitLength.numEntries);\n            index += BitLength.numEntries;\n            for (let j = 0; j < numEntries; j++) {\n                const isARange = BooleanEncoder.decode(encodedString.substr(index, BitLength.anyBoolean));\n                index += BitLength.anyBoolean;\n                const startOrOnlyVendorId = IntEncoder.decode(encodedString.substr(index, BitLength.vendorId), BitLength.vendorId);\n                index += BitLength.vendorId;\n                if (isARange) {\n                    const endVendorId = IntEncoder.decode(encodedString.substr(index, BitLength.vendorId), BitLength.vendorId);\n                    index += BitLength.vendorId;\n                    if (endVendorId < startOrOnlyVendorId) {\n                        throw new DecodingError(`Invalid RangeEntry: endVendorId ${endVendorId} is less than ${startOrOnlyVendorId}`);\n                    }\n                    for (let k = startOrOnlyVendorId; k <= endVendorId; k++) {\n                        vector.add(k, purposeRestriction);\n                    }\n                }\n                else {\n                    vector.add(startOrOnlyVendorId, purposeRestriction);\n                }\n            }\n        }\n        vector.bitLength = index;\n        return vector;\n    }\n}\n","export var VectorEncodingType;\n(function (VectorEncodingType) {\n    VectorEncodingType[VectorEncodingType[\"FIELD\"] = 0] = \"FIELD\";\n    VectorEncodingType[VectorEncodingType[\"RANGE\"] = 1] = \"RANGE\";\n})(VectorEncodingType || (VectorEncodingType = {}));\n","import { Vector } from '../../model/index.js';\nimport { BitLength } from '../index.js';\nimport { IntEncoder } from './IntEncoder.js';\nimport { BooleanEncoder } from './BooleanEncoder.js';\nimport { FixedVectorEncoder } from './FixedVectorEncoder.js';\nimport { VectorEncodingType } from './VectorEncodingType.js';\nimport { DecodingError } from '../../errors/index.js';\nexport class VendorVectorEncoder {\n    static encode(value) {\n        // collectors for range encoding\n        const ranges = [];\n        let range = [];\n        // since both encodings need the maxId, start with that\n        let retrString = IntEncoder.encode(value.maxId, BitLength.maxId);\n        // bit field will be just the vendors as we walk through the vector\n        let bitField = '';\n        let rangeIsSmaller;\n        // some math\n        const headerLength = BitLength.maxId + BitLength.encodingType;\n        const bitFieldLength = headerLength + value.maxId;\n        const minRangeLength = (BitLength.vendorId * 2 + BitLength.singleOrRange + BitLength.numEntries);\n        // gets larger as we walk through the vector\n        let rangeLength = headerLength + BitLength.numEntries;\n        // walk through every value in the vector\n        value.forEach((curValue, i) => {\n            // build our bitfield no matter what\n            bitField += BooleanEncoder.encode(curValue);\n            /**\n             * A range is a minimum of 45 bits, if the number of vendors in this\n             * vector is less than 45 then we know that a bitfield encoding will be\n             * shorter than any range encoding.\n             *\n             * The second check checks while we walk through the vector and abandons\n             * building the ranges once it becomes larger\n             */\n            rangeIsSmaller = (value.maxId > minRangeLength && rangeLength < bitFieldLength);\n            /**\n             * if the curValue is true and our rangeLength is less than the bitField\n             * length, we'll continue to push these ranges into the array.  Once the\n             * ranges become a larger encoding there is no reason to continue\n             * building the structure because we will be choosing the bitfield\n             * encoding\n             */\n            if (rangeIsSmaller && curValue) {\n                /**\n                 * Look ahead to see if this is the last value in our range\n                 */\n                const nextValue = value.has(i + 1);\n                // if there isn't a next value, then we'll wrap up this range\n                if (!nextValue) {\n                    /**\n                     * this is the last value of the range, so we'll push it on to the\n                     * end into position 1\n                     */\n                    range.push(i);\n                    // add to the range length the additional vendorId\n                    rangeLength += BitLength.vendorId;\n                    // store the array in our bigger array\n                    ranges.push(range);\n                    // clear the array for the next range\n                    range = [];\n                }\n                else if (range.length === 0) {\n                    // this is the first  value for this range\n                    range.push(i);\n                    // update our count with new range overhead\n                    rangeLength += BitLength.singleOrRange;\n                    rangeLength += BitLength.vendorId;\n                }\n            }\n        });\n        if (rangeIsSmaller) {\n            retrString += String(VectorEncodingType.RANGE);\n            retrString += this.buildRangeEncoding(ranges);\n        }\n        else {\n            retrString += String(VectorEncodingType.FIELD);\n            retrString += bitField;\n        }\n        return retrString;\n    }\n    static decode(value, version) {\n        let vector;\n        let index = 0;\n        const maxId = IntEncoder.decode(value.substr(index, BitLength.maxId), BitLength.maxId);\n        index += BitLength.maxId;\n        const encodingType = IntEncoder.decode(value.charAt(index), BitLength.encodingType);\n        index += BitLength.encodingType;\n        /**\n         * Range is handled in batches so we'll need a different decoding scheme\n         */\n        if (encodingType === VectorEncodingType.RANGE) {\n            vector = new Vector();\n            if (version === 1) {\n                if (value.substr(index, 1) === '1') {\n                    throw new DecodingError('Unable to decode default consent=1');\n                }\n                // jump over the default encoding\n                index++;\n            }\n            const numEntries = IntEncoder.decode(value.substr(index, BitLength.numEntries), BitLength.numEntries);\n            index += BitLength.numEntries;\n            // loop through each group of entries\n            for (let i = 0; i < numEntries; i++) {\n                // Ranges can represent a single id or a range of ids.\n                const isIdRange = BooleanEncoder.decode(value.charAt(index));\n                index += BitLength.singleOrRange;\n                /**\n                 * regardless of whether or not it's a single entry or range, the next\n                 * set of bits is a vendor ID\n                 */\n                const firstId = IntEncoder.decode(value.substr(index, BitLength.vendorId), BitLength.vendorId);\n                index += BitLength.vendorId;\n                // if it's a range, the next set of bits is the second id\n                if (isIdRange) {\n                    const secondId = IntEncoder.decode(value.substr(index, BitLength.vendorId), BitLength.vendorId);\n                    index += BitLength.vendorId;\n                    // we'll need to set or unset all the vendor ids between the first and second\n                    for (let j = firstId; j <= secondId; j++) {\n                        vector.set(j);\n                    }\n                }\n                else {\n                    vector.set(firstId);\n                }\n            }\n        }\n        else {\n            const bitField = value.substr(index, maxId);\n            index += maxId;\n            vector = FixedVectorEncoder.decode(bitField, maxId);\n        }\n        vector.bitLength = index;\n        return vector;\n    }\n    static buildRangeEncoding(ranges) {\n        // describe the number of entries to follow\n        const numEntries = ranges.length;\n        let rangeString = IntEncoder.encode(numEntries, BitLength.numEntries);\n        // each range\n        ranges.forEach((range) => {\n            // is this range a single?\n            const single = (range.length === 1);\n            // first is the indicator of whether this is a single id or range (two)\n            // 0 is single and range is 1\n            rangeString += BooleanEncoder.encode(!single);\n            // second is the first (or only) vendorId\n            rangeString += IntEncoder.encode(range[0], BitLength.vendorId);\n            if (!single) {\n                // add the second id if it exists\n                rangeString += IntEncoder.encode(range[1], BitLength.vendorId);\n            }\n        });\n        return rangeString;\n    }\n}\n","export * from './BooleanEncoder.js';\nexport * from './DateEncoder.js';\nexport * from './FieldEncoderMap.js';\nexport * from './FixedVectorEncoder.js';\nexport * from './IntEncoder.js';\nexport * from './LangEncoder.js';\nexport * from './PurposeRestrictionVectorEncoder.js';\nexport * from './VectorEncodingType.js';\nexport * from './VendorVectorEncoder.js';\n","export * from './Base64Url.js';\nexport * from './BitLength.js';\nexport * from './EncodingOptions.js';\nexport * from './SegmentEncoder.js';\nexport * from './SemanticPreEncoder.js';\nexport * from './field/index.js';\nexport * from './sequence/index.js';\n","import { Segment, Fields } from '../../model/index.js';\nexport class FieldSequence {\n    '1' = {\n        [Segment.CORE]: [\n            Fields.version,\n            Fields.created,\n            Fields.lastUpdated,\n            Fields.cmpId,\n            Fields.cmpVersion,\n            Fields.consentScreen,\n            Fields.consentLanguage,\n            Fields.vendorListVersion,\n            Fields.purposeConsents,\n            Fields.vendorConsents,\n        ],\n    };\n    '2' = {\n        [Segment.CORE]: [\n            Fields.version,\n            Fields.created,\n            Fields.lastUpdated,\n            Fields.cmpId,\n            Fields.cmpVersion,\n            Fields.consentScreen,\n            Fields.consentLanguage,\n            Fields.vendorListVersion,\n            Fields.policyVersion,\n            Fields.isServiceSpecific,\n            Fields.useNonStandardStacks,\n            Fields.specialFeatureOptins,\n            Fields.purposeConsents,\n            Fields.purposeLegitimateInterests,\n            Fields.purposeOneTreatment,\n            Fields.publisherCountryCode,\n            Fields.vendorConsents,\n            Fields.vendorLegitimateInterests,\n            Fields.publisherRestrictions,\n        ],\n        [Segment.PUBLISHER_TC]: [\n            Fields.publisherConsents,\n            Fields.publisherLegitimateInterests,\n            Fields.numCustomPurposes,\n            Fields.publisherCustomConsents,\n            Fields.publisherCustomLegitimateInterests,\n        ],\n        [Segment.VENDORS_ALLOWED]: [\n            Fields.vendorsAllowed,\n        ],\n        [Segment.VENDORS_DISCLOSED]: [\n            Fields.vendorsDisclosed,\n        ],\n    };\n}\n","import { Segment, Fields, } from '../../model/index.js';\nexport class SegmentSequence {\n    '1' = [\n        Segment.CORE,\n    ];\n    '2' = [\n        Segment.CORE,\n    ];\n    constructor(tcModel, options) {\n        if (tcModel.version === 2) {\n            if (tcModel.isServiceSpecific) {\n                /**\n                 * If it's service specific only, then the publisher TC String can be\n                 * stored in the cookie and would be transmitted if it's not for\n                 * storage.  So it's included regardless of whether or not it's for\n                 * saving or the cmp api to surface.\n                 */\n                this['2'].push(Segment.PUBLISHER_TC);\n            }\n            else {\n                const isForVendors = !!(options && options.isForVendors);\n                /**\n                 * including vendors disclosed only if it is for saving (to the global\n                 * scope and not for vendors through the CMP API) or supportOOB is\n                 * turned on (either or both).  The compliment of this being not for\n                 * saving (surfaced to CMP) and no support of OOB.\n                 */\n                if (!isForVendors || tcModel[Fields.supportOOB] === true) {\n                    this['2'].push(Segment.VENDORS_DISCLOSED);\n                }\n                if (isForVendors) {\n                    /**\n                     * If a publisher does support OOB and they have narrowed the allowed\n                     * vendors to utilize it, then we should include the vendors allowed\n                     * segment.  If it is empty then there are no restrictions, if that\n                     * is intended to mean no support for OOB, then the flag should be\n                     * set for that instead.\n                     *\n                     */\n                    if (tcModel[Fields.supportOOB] && tcModel[Fields.vendorsAllowed].size > 0) {\n                        this['2'].push(Segment.VENDORS_ALLOWED);\n                    }\n                    /**\n                     * Always include the publisher TC segment as long as this TC string\n                     * is not intended to be saved in the global scope.\n                     */\n                    this['2'].push(Segment.PUBLISHER_TC);\n                }\n            }\n        }\n    }\n}\n","export {};\n","// created from 'create-ts-index'\nexport * from './FieldSequence.js';\nexport * from './SegmentSequence.js';\nexport * from './SequenceVersionMap.js';\n","/**\n * class for decoding errors\n *\n * @extends {Error}\n */\nclass DecodingError extends Error {\n    /**\n     * constructor - constructs an DecodingError\n     *\n     * @param {string} msg - Decoding Error Message\n     * @return {undefined}\n     */\n    constructor(msg) {\n        super(msg);\n        this.name = 'DecodingError';\n    }\n}\nexport { DecodingError };\n","/**\n * class for encoding errors\n *\n * @extends {Error}\n */\nclass EncodingError extends Error {\n    /**\n     * constructor - constructs an EncodingError\n     *\n     * @param {string} msg - Encoding Error Message\n     * @return {undefined}\n     */\n    constructor(msg) {\n        super(msg);\n        this.name = 'EncodingError';\n    }\n}\nexport { EncodingError };\n","/**\n * class for General GVL Errors\n *\n * @extends {Error}\n */\nclass GVLError extends Error {\n    /**\n     * constructor - constructs a GVLError\n     *\n     * @param {string} msg - Error message to display\n     * @return {undefined}\n     */\n    constructor(msg) {\n        super(msg);\n        this.name = 'GVLError';\n    }\n}\nexport { GVLError };\n","/**\n * class for decoding errors\n *\n * @extends {Error}\n */\nclass TCModelError extends Error {\n    /**\n     * constructor - constructs an TCModelError\n     *\n     * @param {string} fieldName - the errored field\n     * @param {string} passedValue - what was passed\n     * @return {undefined}\n     */\n    constructor(fieldName, passedValue, msg = '') {\n        super(`invalid value ${passedValue} passed for ${fieldName} ${msg}`);\n        this.name = 'TCModelError';\n    }\n}\nexport { TCModelError };\n","export * from './DecodingError.js';\nexport * from './EncodingError.js';\nexport * from './GVLError.js';\nexport * from './TCModelError.js';\n","// created from 'create-ts-index'\nexport * from './encoder/index.js';\nexport * from './errors/index.js';\nexport * from './model/index.js';\nexport * from './Cloneable.js';\nexport * from './GVL.js';\nexport * from './Json.js';\nexport * from './TCModel.js';\nexport * from './TCString.js';\n","import { Cloneable } from '../Cloneable.js';\nexport class BinarySearchTree extends Cloneable {\n    root = null;\n    getRoot() {\n        return this.root;\n    }\n    isEmpty() {\n        // if root is undefined or null then by definition this is empty\n        return !(this.root);\n    }\n    add(value) {\n        // create new node object\n        const node = {\n            value: value,\n            left: null,\n            right: null,\n        };\n        let current;\n        // first item?\n        if (this.isEmpty()) {\n            this.root = node;\n        }\n        else {\n            // start at the root\n            current = this.root;\n            // infinite loop, figure out where to put it\n            while (true) {\n                // if the value is less than current value; go left\n                if (value < current.value) {\n                    // if it's empty, we can insert\n                    if (current.left === null) {\n                        // insert on the left\n                        current.left = node;\n                        // our work is done here\n                        break;\n                    }\n                    else {\n                        /**\n                         * if there's something there already, we'll reset the pointer and\n                         * wait for the next loop to do something ie. keep traversing\n                         */\n                        current = current.left;\n                    }\n                }\n                else if (value > current.value) {\n                    // if the value is greater than our current value; go right\n                    if (current.right === null) {\n                        // there's nothing to the right, so put it here\n                        current.right = node;\n                        break;\n                    }\n                    else {\n                        /**\n                         * if there's something there already, we'll reset the pointer and\n                         * wait for the next loop to do something ie. keep traversing\n                         */\n                        current = current.right;\n                    }\n                }\n                else {\n                    /**\n                     * If it's neither greater than the right or less than the right then\n                     * it is equal to the current nodes value.  In that case we won't do\n                     * anything with it because we will only insert unique values.\n                     */\n                    break;\n                }\n            }\n        }\n    }\n    /**\n     * performs Morris in-order traversal\n     * @return {number[]} sorted array\n     */\n    get() {\n        const retr = [];\n        let current = this.root;\n        while (current) {\n            if (!current.left) {\n                retr.push(current.value); // if there is no left child, visit current node\n                current = current.right; // then we go the right branch\n            }\n            else {\n                // find the right most leaf of root.left node.\n                let pre = current.left;\n                // when pre.right == null, it means we go to the right most leaf\n                // when pre.right == current, it means the right most leaf has been visited in the last round\n                while (pre.right && pre.right != current) {\n                    pre = pre.right;\n                }\n                // this means the pre.right has been set, it's time to go to current node\n                if (pre.right == current) {\n                    pre.right = null;\n                    // means the current node is pointed by left right most child\n                    // the left branch has been visited, it's time to push the current node\n                    retr.push(current.value);\n                    current = current.right;\n                }\n                else {\n                    // the fist time to visit the pre node, make its right child point to current node\n                    pre.right = current;\n                    current = current.left;\n                }\n            }\n        }\n        return retr;\n    }\n    contains(value) {\n        let retr = false;\n        let current = this.root;\n        while (current) {\n            if (current.value === value) {\n                retr = true;\n                break;\n            }\n            else if (value > current.value) {\n                current = current.right;\n            }\n            else if (value < current.value) {\n                current = current.left;\n            }\n        }\n        return retr;\n    }\n    min(current = this.root) {\n        let retr;\n        while (current) {\n            if (current.left) {\n                current = current.left;\n            }\n            else {\n                retr = current.value;\n                current = null;\n            }\n        }\n        return retr;\n    }\n    max(current = this.root) {\n        let retr;\n        while (current) {\n            if (current.right) {\n                current = current.right;\n            }\n            else {\n                retr = current.value;\n                current = null;\n            }\n        }\n        return retr;\n    }\n    remove(value, current = this.root) {\n        // we start at the root, so the parent is null\n        let parent = null;\n        let parentSide = 'left';\n        while (current) {\n            if (value < current.value) {\n                // set our parent to the current value\n                parent = current;\n                // value is less than current value, so go left\n                current = current.left;\n                parentSide = 'left';\n            }\n            else if (value > current.value) {\n                // set our parent to the current value\n                parent = current;\n                // value is greater than current value, so go right\n                current = current.right;\n                parentSide = 'right';\n            }\n            else {\n                /**\n                   * if it's neither greater than or less than, then it's equal so BINGO!\n                   * we've found it\n                   *\n                   * If we have children, we've got to figure out what to do with\n                   * them once we are no longer around...  Woah, code is like real\n                   * life...\n                   *\n                   * There are three cases we care about when it comes to this removal\n                   * process:\n                   *\n                   * 1. No children -- If not children we just delete an do nothing\n                   * else, no harm no foul.\n                   *\n                   * 2. One child -- Just link the parent's link to current to the\n                   * child.\n                   *\n                   * 3. Two children --  Find the minimum value from the right subtree\n                   * replace us with the minimum value and of course remove that\n                   * minimum value from the right stubtree\n                   */\n                if (!current.left && !current.right) {\n                    // case 1 there are no children easy peasy lemon squeezy\n                    if (parent) {\n                        parent[parentSide] = null;\n                    }\n                    else {\n                        this.root = null;\n                    }\n                }\n                else if (!current.left) {\n                    // no left side only right, so link right\n                    if (parent) {\n                        parent[parentSide] = current.right;\n                    }\n                    else {\n                        this.root = current.right;\n                    }\n                }\n                else if (!current.right) {\n                    // no right side only left, so link left\n                    if (parent) {\n                        parent[parentSide] = current.left;\n                    }\n                    else {\n                        this.root = current.left;\n                    }\n                }\n                else {\n                    /**\n                     * case 3 just like real life, if you delete a parent the more kids\n                     * that parent has the more complicated things get... in this case we\n                     * have two children.  We're gonna have to figure out who goes where.\n                     */\n                    const minVal = this.min(current.right);\n                    // little bit of recursion...\n                    this.remove(minVal, current.right);\n                    current.value = minVal;\n                }\n                current = null;\n            }\n        }\n    }\n    /**\n     * Build Binary Search Tree from the ordered number array.\n     *  The depth of the tree will be the `log2` of the array length.\n     * @param {number[]} values number array in ascending order\n     * @return {BinarySearchTree} Binary Search Tree\n     */\n    static build(values) {\n        if (!values || values.length === 0) {\n            return null;\n        }\n        else if (values.length === 1) {\n            const tree = new BinarySearchTree();\n            tree.add(values[0]);\n            return tree;\n        }\n        else {\n            const rootIndex = values.length >> 1;\n            const tree = new BinarySearchTree();\n            tree.add(values[rootIndex]);\n            const root = tree.getRoot();\n            if (root) {\n                if (rootIndex + 1 < values.length) {\n                    const rightTree = BinarySearchTree.build(values.slice(rootIndex + 1));\n                    root.right = rightTree ? rightTree.getRoot() : null;\n                }\n                if (rootIndex - 1 > 0) {\n                    const leftTree = BinarySearchTree.build(values.slice(0, rootIndex - 1));\n                    root.left = leftTree ? leftTree.getRoot() : null;\n                }\n            }\n            return tree;\n        }\n    }\n}\n","export class ConsentLanguages {\n    static langSet = new Set([\n        'BG',\n        'CA',\n        'CS',\n        'DA',\n        'DE',\n        'EL',\n        'EN',\n        'ES',\n        'ET',\n        'FI',\n        'FR',\n        'HR',\n        'HU',\n        'IT',\n        'JA',\n        'LT',\n        'LV',\n        'MT',\n        'NL',\n        'NO',\n        'PL',\n        'PT',\n        'RO',\n        'RU',\n        'SK',\n        'SL',\n        'SV',\n        'TR',\n        'ZH',\n    ]);\n    has(key) {\n        return ConsentLanguages.langSet.has(key);\n    }\n    forEach(callback) {\n        ConsentLanguages.langSet.forEach(callback);\n    }\n    get size() {\n        return ConsentLanguages.langSet.size;\n    }\n}\n","export {};\n","export var DeviceDisclosureStorageAccessType;\n(function (DeviceDisclosureStorageAccessType) {\n    DeviceDisclosureStorageAccessType[\"COOKIE\"] = \"cookie\";\n    DeviceDisclosureStorageAccessType[\"WEB\"] = \"web\";\n    DeviceDisclosureStorageAccessType[\"APP\"] = \"app\";\n})(DeviceDisclosureStorageAccessType || (DeviceDisclosureStorageAccessType = {}));\n","export class Fields {\n    static cmpId = 'cmpId';\n    static cmpVersion = 'cmpVersion';\n    static consentLanguage = 'consentLanguage';\n    static consentScreen = 'consentScreen';\n    static created = 'created';\n    static supportOOB = 'supportOOB';\n    static isServiceSpecific = 'isServiceSpecific';\n    static lastUpdated = 'lastUpdated';\n    static numCustomPurposes = 'numCustomPurposes';\n    static policyVersion = 'policyVersion';\n    static publisherCountryCode = 'publisherCountryCode';\n    static publisherCustomConsents = 'publisherCustomConsents';\n    static publisherCustomLegitimateInterests = 'publisherCustomLegitimateInterests';\n    static publisherLegitimateInterests = 'publisherLegitimateInterests';\n    static publisherConsents = 'publisherConsents';\n    static publisherRestrictions = 'publisherRestrictions';\n    static purposeConsents = 'purposeConsents';\n    static purposeLegitimateInterests = 'purposeLegitimateInterests';\n    static purposeOneTreatment = 'purposeOneTreatment';\n    static specialFeatureOptins = 'specialFeatureOptins';\n    static useNonStandardStacks = 'useNonStandardStacks';\n    static vendorConsents = 'vendorConsents';\n    static vendorLegitimateInterests = 'vendorLegitimateInterests';\n    static vendorListVersion = 'vendorListVersion';\n    static vendorsAllowed = 'vendorsAllowed';\n    static vendorsDisclosed = 'vendorsDisclosed';\n    static version = 'version';\n}\n","export {};\n","export {};\n","import { Cloneable } from '../Cloneable.js';\nimport { TCModelError } from '../errors/index.js';\nimport { RestrictionType } from './RestrictionType.js';\nexport class PurposeRestriction extends Cloneable {\n    static hashSeparator = '-';\n    purposeId_;\n    restrictionType;\n    /**\n     * constructor\n     *\n     * @param {number} purposeId? - may optionally pass the purposeId into the\n     * constructor\n     * @param {RestrictionType} restrictionType? - may\n     * optionally pass the restrictionType into the constructor\n     * @return {undefined}\n     */\n    constructor(purposeId, restrictionType) {\n        super();\n        if (purposeId !== undefined) {\n            this.purposeId = purposeId;\n        }\n        if (restrictionType !== undefined) {\n            this.restrictionType = restrictionType;\n        }\n    }\n    static unHash(hash) {\n        const splitUp = hash.split(this.hashSeparator);\n        const purpRestriction = new PurposeRestriction();\n        if (splitUp.length !== 2) {\n            throw new TCModelError('hash', hash);\n        }\n        purpRestriction.purposeId = parseInt(splitUp[0], 10);\n        purpRestriction.restrictionType = parseInt(splitUp[1], 10);\n        return purpRestriction;\n    }\n    get hash() {\n        if (!this.isValid()) {\n            throw new Error('cannot hash invalid PurposeRestriction');\n        }\n        return `${this.purposeId}${PurposeRestriction.hashSeparator}${this.restrictionType}`;\n    }\n    /**\n     * @return {number} The purpose Id associated with a publisher\n     * purpose-by-vendor restriction that resulted in a different consent or LI\n     * status than the consent or LI purposes allowed lists.\n     */\n    get purposeId() {\n        return this.purposeId_;\n    }\n    /**\n     * @param {number} idNum - The purpose Id associated with a publisher\n     * purpose-by-vendor restriction that resulted in a different consent or LI\n     * status than the consent or LI purposes allowed lists.\n     */\n    set purposeId(idNum) {\n        this.purposeId_ = idNum;\n    }\n    isValid() {\n        return (Number.isInteger(this.purposeId) &&\n            this.purposeId > 0 &&\n            (this.restrictionType === RestrictionType.NOT_ALLOWED ||\n                this.restrictionType === RestrictionType.REQUIRE_CONSENT ||\n                this.restrictionType === RestrictionType.REQUIRE_LI));\n    }\n    isSameAs(otherPR) {\n        return (this.purposeId === otherPR.purposeId &&\n            this.restrictionType === otherPR.restrictionType);\n    }\n}\n","import { PurposeRestriction } from './PurposeRestriction.js';\nimport { BinarySearchTree } from './BinarySearchTree.js';\nimport { RestrictionType } from './RestrictionType.js';\nimport { Cloneable } from '../Cloneable.js';\nexport class PurposeRestrictionVector extends Cloneable {\n    /**\n     * if this originatd from an encoded string we'll need a place to store the\n     * bit length; it can be set and got from here\n     */\n    bitLength = 0;\n    /**\n     * a map indexed by a string which will be a 'hash' of the purpose and\n     * restriction type.\n     *\n     * Using a BST to keep vendors in a sorted order for encoding later\n     */\n    map = new Map();\n    gvl_;\n    has(hash) {\n        return this.map.has(hash);\n    }\n    isOkToHave(restrictionType, purposeId, vendorId) {\n        let result = true;\n        /**\n         * without a gvl set, there's no way to know... in that case we'll return\n         * true but once the GVL is set later we'll go through these and clean up\n         * the mess.\n         */\n        if (this.gvl?.vendors) {\n            const vendor = this.gvl.vendors[vendorId];\n            if (vendor) {\n                if (restrictionType === RestrictionType.NOT_ALLOWED) {\n                    /**\n                     * if it's \"not allowed\" then flexible declaration is ignored but if\n                     * if it isn't even listed as one of the purposes the vendor uses,\n                     * then there is no reason to encode the value so check both arrays\n                     * to see if it exists.  If it does then we can restrict it.\n                     */\n                    result = (vendor.legIntPurposes.includes(purposeId) || vendor.purposes.includes(purposeId));\n                }\n                else if (vendor.flexiblePurposes.length) {\n                    switch (restrictionType) {\n                        /**\n                         * If the vendor has the purposeId in flexiblePurposes and it is\n                         * listed as a legitimate interest purpose we can set the\n                         * override to require consent.\n                         */\n                        case RestrictionType.REQUIRE_CONSENT:\n                            result = (vendor.flexiblePurposes.includes(purposeId) && vendor.legIntPurposes.includes(purposeId));\n                            break;\n                        /**\n                         * If the vendor has the purposeId in flexiblePurposes and it is\n                         * listed as a consent purpose we can set the\n                         * override to require legitimate interest.\n                         */\n                        case RestrictionType.REQUIRE_LI:\n                            result = (vendor.flexiblePurposes.includes(purposeId) && vendor.purposes.includes(purposeId));\n                            break;\n                    }\n                }\n                else {\n                    result = false;\n                }\n            }\n            else {\n                // this vendor doesn't exist\n                result = false;\n            }\n        }\n        // if the gvl isn't defined, we can't do anything until later\n        return result;\n    }\n    /**\n     * add - adds a given Vendor ID under a given Purpose Restriction\n     *\n     * @param {number} vendorId\n     * @param {PurposeRestriction} purposeRestriction\n     * @return {void}\n     */\n    add(vendorId, purposeRestriction) {\n        if (this.isOkToHave(purposeRestriction.restrictionType, purposeRestriction.purposeId, vendorId)) {\n            const hash = purposeRestriction.hash;\n            if (!this.has(hash)) {\n                this.map.set(hash, new BinarySearchTree());\n                this.bitLength = 0;\n            }\n            /**\n             * Previously I had a check here to remove a duplicate value, but because\n             * we're using a tree the value is guaranteed to be unique so there is no\n             * need to add an additional de-duplication here.\n             */\n            this.map.get(hash).add(vendorId);\n        }\n    }\n    /**\n     * restrictPurposeToLegalBasis - adds all Vendors under a given Purpose Restriction\n     *\n     * @param {PurposeRestriction} purposeRestriction\n     * @return {void}\n     */\n    restrictPurposeToLegalBasis(purposeRestriction) {\n        const vendors = this.gvl.vendorIds;\n        const hash = purposeRestriction.hash;\n        const lastEntry = (function () {\n            let value;\n            for (value of vendors)\n                ;\n            return value;\n        })();\n        /**\n         * Create an ordered array of vendor IDs from `1` (the minimum value for Vendor ID) to `lastEntry`\n         */\n        const values = [...Array(lastEntry).keys()].map((i) => i + 1);\n        for (let i = 1; i <= lastEntry; i++) {\n            if (!this.has(hash)) {\n                this.map.set(hash, BinarySearchTree.build(values)); // use static method `build` to create a `BST` from the ordered array of IDs\n                this.bitLength = 0;\n            }\n            /**\n             * Previously I had a check here to remove a duplicate value, but because\n             * we're using a tree the value is guaranteed to be unique so there is no\n             * need to add an additional de-duplication here.\n             */\n            this.map.get(hash).add(i);\n        }\n    }\n    /**\n     * getVendors - returns array of vendor ids optionally narrowed by a given\n     * Purpose Restriction.  If no purpose restriction is passed then all vendor\n     * ids will be returned.  One can expect this result to be a unique set of\n     * ids no duplicates.\n     *\n     * @param {PurposeRestriction} [purposeRestriction] - optionally passed to\n     * get only Vendor IDs restricted under the given Purpose Restriction\n     * @return {number[]} - Unique ID set of vendors\n     */\n    getVendors(purposeRestriction) {\n        let vendorIds = [];\n        if (purposeRestriction) {\n            const hash = purposeRestriction.hash;\n            if (this.has(hash)) {\n                vendorIds = this.map.get(hash).get();\n            }\n        }\n        else {\n            const vendorSet = new Set();\n            this.map.forEach((bst) => {\n                bst.get().forEach((vendorId) => {\n                    vendorSet.add(vendorId);\n                });\n            });\n            vendorIds = Array.from(vendorSet);\n        }\n        return vendorIds;\n    }\n    getRestrictionType(vendorId, purposeId) {\n        let rType;\n        this.getRestrictions(vendorId).forEach((purposeRestriction) => {\n            if (purposeRestriction.purposeId === purposeId) {\n                if (rType === undefined || rType > purposeRestriction.restrictionType) {\n                    rType = purposeRestriction.restrictionType;\n                }\n            }\n        });\n        return rType;\n    }\n    /**\n     * vendorHasRestriction - determines whether a given Vendor ID is under a\n     * given Purpose Restriction\n     *\n     * @param {number} vendorId\n     * @param {PurposeRestriction} purposeRestriction\n     * @return {boolean} - true if the give Vendor ID is under the given Purpose\n     * Restriction\n     */\n    vendorHasRestriction(vendorId, purposeRestriction) {\n        let has = false;\n        const restrictions = this.getRestrictions(vendorId);\n        for (let i = 0; i < restrictions.length && !has; i++) {\n            has = purposeRestriction.isSameAs(restrictions[i]);\n        }\n        return has;\n    }\n    /**\n     * getMaxVendorId - gets the Maximum Vendor ID regardless of Purpose\n     * Restriction\n     *\n     * @return {number} - maximum Vendor ID\n     */\n    getMaxVendorId() {\n        let retr = 0;\n        this.map.forEach((bst) => {\n            retr = Math.max(bst.max(), retr);\n        });\n        return retr;\n    }\n    getRestrictions(vendorId) {\n        const retr = [];\n        this.map.forEach((bst, hash) => {\n            if (vendorId) {\n                if (bst.contains(vendorId)) {\n                    retr.push(PurposeRestriction.unHash(hash));\n                }\n            }\n            else {\n                retr.push(PurposeRestriction.unHash(hash));\n            }\n        });\n        return retr;\n    }\n    getPurposes() {\n        const purposeIds = new Set();\n        this.map.forEach((bst, hash) => {\n            purposeIds.add(PurposeRestriction.unHash(hash).purposeId);\n        });\n        return Array.from(purposeIds);\n    }\n    /**\n     * remove - removes Vendor ID from a Purpose Restriction\n     *\n     * @param {number} vendorId\n     * @param {PurposeRestriction} purposeRestriction\n     * @return {void}\n     */\n    remove(vendorId, purposeRestriction) {\n        const hash = purposeRestriction.hash;\n        const bst = this.map.get(hash);\n        if (bst) {\n            bst.remove(vendorId);\n            // if it's empty let's delete the key so it doesn't show up empty\n            if (bst.isEmpty()) {\n                this.map.delete(hash);\n                this.bitLength = 0;\n            }\n        }\n    }\n    /**\n     * Essential for being able to determine whether we can actually set a\n     * purpose restriction since they have to have a flexible legal basis\n     *\n     * @param {GVL} value - the GVL instance\n     */\n    set gvl(value) {\n        if (!this.gvl_) {\n            this.gvl_ = value;\n            /**\n             * if we have restrictions set before the gvl is set then we'll have to\n             * go through and remove some if they're not valid\n             */\n            this.map.forEach((bst, hash) => {\n                const purposeRestriction = PurposeRestriction.unHash(hash);\n                const vendors = bst.get();\n                vendors.forEach((vendorId) => {\n                    if (!this.isOkToHave(purposeRestriction.restrictionType, purposeRestriction.purposeId, vendorId)) {\n                        bst.remove(vendorId);\n                    }\n                });\n            });\n        }\n    }\n    /**\n     * gvl returns local copy of the GVL these restrictions apply to\n     *\n     * @return {GVL}\n     */\n    get gvl() {\n        return this.gvl_;\n    }\n    /**\n     * isEmpty - whether or not this vector has any restrictions in it\n     *\n     * @return {boolean}\n     */\n    isEmpty() {\n        return this.map.size === 0;\n    }\n    ;\n    /**\n     * numRestrictions - returns the number of Purpose Restrictions.\n     *\n     * @return {number}\n     */\n    get numRestrictions() {\n        return this.map.size;\n    }\n}\n","/**\n * if a Vendor has declared flexible purposes (see: [[Vendor]] under\n * `flexiblePurposeIds`) on the Global Vendor List ([[Declarations]]) a CMP may\n * change their legal basis for processing in the encoding.\n */\nexport var RestrictionType;\n(function (RestrictionType) {\n    /**\n     * under no circumstances is this purpose allowed.\n     */\n    RestrictionType[RestrictionType[\"NOT_ALLOWED\"] = 0] = \"NOT_ALLOWED\";\n    /**\n     * if the default declaration is legitimate interest then this flips the purpose to consent in the encoding.\n     */\n    RestrictionType[RestrictionType[\"REQUIRE_CONSENT\"] = 1] = \"REQUIRE_CONSENT\";\n    /**\n     * if the default declaration is consent then this flips the purpose to Legitimate Interest in the encoding.\n     */\n    RestrictionType[RestrictionType[\"REQUIRE_LI\"] = 2] = \"REQUIRE_LI\";\n})(RestrictionType || (RestrictionType = {}));\n","export var Segment;\n(function (Segment) {\n    Segment[\"CORE\"] = \"core\";\n    Segment[\"VENDORS_DISCLOSED\"] = \"vendorsDisclosed\";\n    Segment[\"VENDORS_ALLOWED\"] = \"vendorsAllowed\";\n    Segment[\"PUBLISHER_TC\"] = \"publisherTC\";\n})(Segment || (Segment = {}));\n","import { Segment } from './Segment.js';\nexport class SegmentIDs {\n    /**\n     * 0 = default - reserved for core string (does not need to be present in the core string)\n     * 1 = OOB vendors disclosed\n     * 2 = OOB vendors allowed\n     * 3 = PublisherTC\n     */\n    static ID_TO_KEY = [\n        Segment.CORE,\n        Segment.VENDORS_DISCLOSED,\n        Segment.VENDORS_ALLOWED,\n        Segment.PUBLISHER_TC,\n    ];\n    static KEY_TO_ID = {\n        [Segment.CORE]: 0,\n        [Segment.VENDORS_DISCLOSED]: 1,\n        [Segment.VENDORS_ALLOWED]: 2,\n        [Segment.PUBLISHER_TC]: 3,\n    };\n}\n","import { Cloneable } from '../Cloneable.js';\nimport { TCModelError } from '../errors/index.js';\n/**\n * Vector class is like a Set except it keeps track of a max id\n */\nexport class Vector extends Cloneable {\n    /**\n     * if this originatd from an encoded string we'll need a place to store the\n     * bit length; it can be set and got from here\n     */\n    bitLength = 0;\n    maxId_ = 0;\n    set_ = new Set();\n    *[Symbol.iterator]() {\n        for (let i = 1; i <= this.maxId; i++) {\n            yield [i, this.has(i)];\n        }\n    }\n    /**\n     * values()\n     *\n     * @return {IterableIterator<number>} - returns an iterator of the positive\n     * values in the set\n     */\n    values() {\n        return this.set_.values();\n    }\n    /**\n     * maxId\n     *\n     * @return {number} - the highest id in this Vector\n     */\n    get maxId() {\n        return this.maxId_;\n    }\n    /**\n     * get\n     *\n     * @param {number} id - key for value to check\n     * @return {boolean} - value of that key, if never set it will be false\n     */\n    has(id) {\n        /**\n         * if it exists in the set we'll return true\n         */\n        return this.set_.has(id);\n    }\n    /**\n     * unset\n     *\n     * @param {SingleIDOrCollection} id - id or ids to unset\n     * @return {void}\n     */\n    unset(id) {\n        if (Array.isArray(id)) {\n            id.forEach((id) => this.unset(id));\n        }\n        else if (typeof id === 'object') {\n            this.unset(Object.keys(id).map((strId) => Number(strId)));\n        }\n        else {\n            this.set_.delete(Number(id));\n            /**\n             * if bitLength was set before, it must now be unset\n             */\n            this.bitLength = 0;\n            if (id === this.maxId) {\n                /**\n                 * aww bummer we lost our maxId... now we've got to search through\n                 * all the ids and find the biggest one.\n                 */\n                this.maxId_ = 0;\n                this.set_.forEach((id) => {\n                    this.maxId_ = Math.max(this.maxId, id);\n                });\n            }\n        }\n    }\n    isIntMap(item) {\n        let result = (typeof item === 'object');\n        result = (result && Object.keys(item).every((key) => {\n            let itemResult = Number.isInteger(parseInt(key, 10));\n            itemResult = (itemResult && this.isValidNumber(item[key].id));\n            itemResult = (itemResult && item[key].name !== undefined);\n            return itemResult;\n        }));\n        return result;\n    }\n    isValidNumber(item) {\n        return (parseInt(item, 10) > 0);\n    }\n    isSet(item) {\n        let result = false;\n        if (item instanceof Set) {\n            result = Array.from(item).every(this.isValidNumber);\n        }\n        return result;\n    }\n    /**\n     * set - sets an item assumed to be a truthy value by its presence\n     *\n     * @param {SingleIDOrCollection} item - May be a single id (positive integer)\n     * or collection of ids in a set, GVL Int Map, or Array.\n     *\n     * @return {void}\n     */\n    set(item) {\n        /**\n         * strategy here is to just recursively call set if it's a collection until\n         * we get to the final integer ID\n         */\n        if (Array.isArray(item)) {\n            item.forEach((item) => this.set(item));\n        }\n        else if (this.isSet(item)) {\n            this.set(Array.from(item));\n        }\n        else if (this.isIntMap(item)) {\n            this.set(Object.keys(item).map((strId) => Number(strId)));\n        }\n        else if (this.isValidNumber(item)) {\n            this.set_.add(item);\n            this.maxId_ = Math.max(this.maxId, item);\n            /**\n             * if bitLength was set before, it must now be unset\n             */\n            this.bitLength = 0;\n        }\n        else {\n            /**\n             * Super not cool to try and set something that's not valid\n             */\n            throw new TCModelError('set()', item, 'must be positive integer array, positive integer, Set<number>, or IntMap');\n        }\n    }\n    empty() {\n        this.set_ = new Set();\n    }\n    /**\n     * forEach - to traverse from id=1 to id=maxId in a sequential non-sparse manner\n     *\n     *\n     * @param {forEachCallback} callback - callback to execute\n     * @return {void}\n     *\n     * @callback forEachCallback\n     * @param {boolean} value - whether or not this id exists in the vector\n     * @param {number} id - the id number of the current iteration\n     */\n    forEach(callback) {\n        for (let i = 1; i <= this.maxId; i++) {\n            callback(this.has(i), i);\n        }\n    }\n    get size() {\n        return this.set_.size;\n    }\n    setAll(intMap) {\n        this.set(intMap);\n    }\n}\n","export {};\n","export {};\n",";\nexport {};\n","export {};\n","export {};\n","export {};\n","export {};\n","export {};\n","export {};\n","// created from 'create-ts-index'\nexport * from './ByPurposeVendorMap.js';\nexport * from './Declarations.js';\nexport * from './Feature.js';\nexport * from './GVLMapItem.js';\nexport * from './IDSetMap.js';\nexport * from './Purpose.js';\nexport * from './Stack.js';\nexport * from './Vendor.js';\nexport * from './VendorList.js';\n","export * from './BinarySearchTree.js';\nexport * from './ConsentLanguages.js';\nexport * from './Fields.js';\nexport * from './IntMap.js';\nexport * from './KeyMap.js';\nexport * from './PurposeRestriction.js';\nexport * from './PurposeRestrictionVector.js';\nexport * from './DeviceDisclosureStorageAccessType.js';\nexport * from './DeviceDisclosure.js';\nexport * from './RestrictionType.js';\nexport * from './Segment.js';\nexport * from './SegmentIDs.js';\nexport * from './Vector.js';\nexport * from './gvl/index.js';\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { TCString } from \"@iabtcf/core\";\n\nconst decodedString = TCString.decode(\n  \"CPvaSZ0PvaSaIErADDENDPCsAP_AAH_AACiQJkNX_H__bW9r8f7_aft0eY1P9_j77uQxBhfJk-4F3LvW_JwX52E5NF36tqoKmR4Eu3ZBIUNlHNHUTVmwaokVryHsak2cpTNKJ6BEkFMRM2dYCF5vm5tjeQKY5_p_d3fx2D-t_dv839z3z81Xn3d5f--0-PCdU5-9Dfn9fRfb-9IP9_78v8v8_1_rk2_eT13_79_7_D9-f_87_XQTFAJMNS4gC7AgZCbQMIoUQIwrCAigUAAAAkDRAQAuDAp2RgE-sBkAKEUARwQAhgBRkACAAACAJCIAJAiwQAAQCAQAAgAQCAQAEDAAKACwEAgABAdAxTCgAUCwgSICIhTAhKgSCAlsqEEoLpBXCAKssAKARGwUACIAARWAAICxcAwRICVCQQJdQbQAAEACAUSoViCT00ACgkbLUAAA.YAAAAAAAAAAA\"\n);\n\nconsole.log(decodedString);\n"],"names":["TCString","decodedString","decode","console","log"],"sourceRoot":""}